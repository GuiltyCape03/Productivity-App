"use client";

import React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar, AreaChart, Area } from "recharts";
import { v4 as uuidv4 } from "uuid";
import { format } from "date-fns";
import {
  Settings,
  Download,
  Upload,
  Timer,
  Focus,
  Keyboard,
  Rocket,
  Sun,
  Moon,
  Bell,
  Sparkles,
  Target,
  Lightbulb,
  CheckCircle2,
  Pencil,
  Trash2,
  ListPlus,
  Filter,
  PartyPopper,
  XCircle,
  CalendarDays,
  Palette,
  Send,
  Star,
  RefreshCw,
  Plus,
  LayoutDashboard,
  BookOpen,
  Minus,
  Link2,
} from "lucide-react";

// ============== Tipos ==============
/** Una meta medible, tipo OKR minimalista. */
type Goal = {
  id: string;
  title: string;
  project: string; // economía, investigación, cursos, etc.
  targetUnits: number; // unidades a lograr (ej. páginas, problemas, horas)
  unitLabel: string; // "páginas", "ejercicios", "horas"
  dueDate?: string; // ISO
  createdAt: string; // ISO
  history: { date: string; units: number }[]; // registro diario de avance
};

/** Una tarea ejecutable y concreta. */
type Task = {
  id: string;
  title: string;
  project: string; // etiqueta para agrupar
  estimateMin: number; // estimación grosera
  dueDate?: string; // ISO
  notes?: string;
  points: number; // ponderación para el score diario
  done: boolean;
  createdAt: string; // ISO
  priority: "low" | "med" | "high";
};

type AiPlanItem = {
  id: string;
  title: string;
  project: string;
  estimateMin: number;
  reason: string;
  score: number;
  kind: "existing" | "suggested";
  existingTaskId?: string;
};

type AiGoalPulse = {
  goalId: string;
  goalTitle: string;
  message: string;
  urgency: "low" | "medium" | "high";
  recommendedUnits: number;
  unitLabel: string;
};

type AiSuggestion = {
  id: string;
  headline: string;
  detail: string;
};

type AiEngineSnapshot = {
  summary: string;
  stats: {
    totalPending: number;
    highPriority: number;
    overdue: number;
    capacityMin: number;
    planMinutes: number;
  };
  plan: AiPlanItem[];
  commitments: AiGoalPulse[];
  suggestions: AiSuggestion[];
};

type AiFocusState = {
  date: string;
  taskIds: string[];
  summary?: string;
};

/** Cierre de día con score. */
type DailyReview = {
  id: string;
  date: string; // ISO solo día
  score: number; // 0 a 100
  completedTasks: string[]; // ids
  notes?: string;
};

type WorkspaceBlock = {
  id: string;
  type: "heading" | "todo" | "text" | "divider";
  text: string;
  checked?: boolean;
  accent?: string;
};

type WorkspacePage = {
  id: string;
  icon: string;
  title: string;
  description?: string;
  color: string;
  createdAt: string;
  updatedAt: string;
  tags: string[];
  favorite?: boolean;
  blocks: WorkspaceBlock[];
};

type WorkspaceTemplateKey = "blank" | "daily" | "project" | "knowledge";

type GoogleCalendarConfig = {
  apiKey: string;
  clientId: string;
  calendarId: string;
  timeZone: string;
  lookAheadDays: number;
};

type GoogleCalendarProfile = {
  name?: string;
  email?: string;
  avatar?: string;
};

type GoogleCalendarEvent = {
  id: string;
  summary: string;
  start: string;
  end: string;
  location?: string;
  hangoutLink?: string;
  description?: string;
};

type GoogleCalendarState = {
  status: "idle" | "loading" | "connected" | "error";
  message?: string;
  events: GoogleCalendarEvent[];
  profile?: GoogleCalendarProfile;
  lastSyncedAt?: string;
};

type ChatMessage = {
  id: string;
  role: "user" | "bot";
  text: string;
  timestamp: string;
};

type UiPreferences = {
  cardStyle: "glass" | "solid" | "gradient";
  cardRadius: "md" | "lg" | "xl";
  accent: "emerald" | "violet" | "amber" | "sky" | "slate";
  density: "comfortable" | "cozy" | "compact";
  dialogBlur: number;
  cardShadow: "soft" | "medium" | "bold";
  dialogTone: "neutral" | "accent" | "inverted";
  fieldStyle: "glassy" | "solid" | "minimal";
  defaultProjectName: string;
  supportProjectName: string;
};

type SurfaceTokens = {
  card: string;
  dialog: string;
  dialogStyle: React.CSSProperties;
  accentRing: string;
  accentSoft: string;
  hover: string;
  subtle: string;
  field: string;
  fieldArea: string;
  density: UiPreferences["density"];
  accentName: UiPreferences["accent"];
};

const SurfaceContext = React.createContext<SurfaceTokens>({
  card: "",
  dialog: "",
  dialogStyle: {},
  accentRing: "",
  accentSoft: "",
  hover: "",
  subtle: "",
  field: "",
  fieldArea: "",
  density: "comfortable",
  accentName: "emerald",
});

function useSurface() {
  return useContext(SurfaceContext);
}

const SurfaceCard = React.forwardRef<HTMLDivElement, React.ComponentProps<typeof Card>>(
  ({ className, ...props }, ref) => {
    const surface = useSurface();
    return <Card ref={ref} className={cx(surface.card, surface.hover, className)} {...props} />;
  },
);
SurfaceCard.displayName = "SurfaceCard";

const DEFAULT_PROJECTS: string[] = [];

const DEFAULT_UI_PREFS: UiPreferences = {
  cardStyle: "glass",
  cardRadius: "xl",
  accent: "emerald",
  density: "comfortable",
  dialogBlur: 18,
  cardShadow: "medium",
  dialogTone: "neutral",
  fieldStyle: "glassy",
  defaultProjectName: "Mi proyecto clave",
  supportProjectName: "Operaciones",
};

function cx(...values: (string | false | null | undefined)[]) {
  return values.filter(Boolean).join(" ");
}

const NEW_PROJECT_VALUE = "__new_project__";

// ============== Helpers Persistencia ==============
const LS_KEYS = {
  goals: "nahum_cls_goals",
  tasks: "nahum_cls_tasks",
  reviews: "nahum_cls_reviews",
  cfg: "nahum_cls_cfg",
  projects: "nahum_cls_projects",
  focus: "nahum_cls_focus",
  workspace: "nahum_cls_workspace_pages",
  workspaceActive: "nahum_cls_workspace_active",
  gcalCfg: "nahum_cls_google_calendar_cfg",
  gcalState: "nahum_cls_google_calendar_state",
  uiPrefs: "nahum_cls_ui_prefs",
};

type Cfg = {
  theme: "light" | "dark";
  lang: "es" | "en";
  focusBlockMin: number; // default 25
  breakMin: number; // default 5
  sound: boolean;
  notifications: boolean;
  dailyCapacityMin: number;
  dailyMinSlots: number;
};

const DEFAULT_CFG: Cfg = {
  theme: "light",
  lang: "es",
  focusBlockMin: 25,
  breakMin: 5,
  sound: true,
  notifications: false,
  dailyCapacityMin: 240,
  dailyMinSlots: 3,
};

const WORKSPACE_COLORS = [
  "emerald",
  "sky",
  "violet",
  "amber",
  "rose",
  "slate",
] as const;

const WORKSPACE_COLOR_STYLES: Record<string, { bg: string; ring: string; text: string; pill: string }> = {
  emerald: {
    bg: "from-emerald-500/15 via-emerald-500/5 to-transparent",
    ring: "ring-emerald-400/60",
    text: "text-emerald-900 dark:text-emerald-100",
    pill: "bg-emerald-500/15 text-emerald-700 dark:text-emerald-200",
  },
  sky: {
    bg: "from-sky-500/15 via-sky-500/5 to-transparent",
    ring: "ring-sky-400/60",
    text: "text-sky-900 dark:text-sky-100",
    pill: "bg-sky-500/15 text-sky-700 dark:text-sky-200",
  },
  violet: {
    bg: "from-violet-500/15 via-violet-500/5 to-transparent",
    ring: "ring-violet-400/60",
    text: "text-violet-900 dark:text-violet-100",
    pill: "bg-violet-500/15 text-violet-700 dark:text-violet-200",
  },
  amber: {
    bg: "from-amber-500/20 via-amber-500/10 to-transparent",
    ring: "ring-amber-400/60",
    text: "text-amber-900 dark:text-amber-100",
    pill: "bg-amber-500/15 text-amber-700 dark:text-amber-200",
  },
  rose: {
    bg: "from-rose-500/15 via-rose-500/5 to-transparent",
    ring: "ring-rose-400/60",
    text: "text-rose-900 dark:text-rose-100",
    pill: "bg-rose-500/15 text-rose-700 dark:text-rose-200",
  },
  slate: {
    bg: "from-slate-500/15 via-slate-500/5 to-transparent",
    ring: "ring-slate-400/60",
    text: "text-slate-900 dark:text-slate-100",
    pill: "bg-slate-500/10 text-slate-700 dark:text-slate-200",
  },
  default: {
    bg: "from-neutral-500/10 via-neutral-500/5 to-transparent",
    ring: "ring-neutral-400/50",
    text: "text-neutral-900 dark:text-neutral-100",
    pill: "bg-neutral-500/10 text-neutral-700 dark:text-neutral-200",
  },
};

function createDefaultWorkspacePages(): WorkspacePage[] {
  return [];
}

const DEFAULT_GCAL_CFG: GoogleCalendarConfig = {
  apiKey: "",
  clientId: "",
  calendarId: "primary",
  timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone || "America/Mexico_City",
  lookAheadDays: 7,
};

function loadLS<T>(key: string, fallback: T): T {
  try {
    const raw = localStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : fallback;
  } catch {
    return fallback;
  }
}

function saveLS<T>(key: string, value: T) {
  localStorage.setItem(key, JSON.stringify(value));
}

function todayISO(): string {
  const d = new Date();
  return new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString();
}

function toISODate(dateStr?: string) {
  if (!dateStr) return undefined;
  const d = new Date(dateStr);
  return new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString();
}

function playBeep() {
  try {
    const ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine"; o.frequency.value = 880; o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(0.001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.02);
    o.start();
    setTimeout(() => { g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2); o.stop(ctx.currentTime + 0.21); }, 200);
  } catch {}
}

function diffDays(fromIso: string, toIso: string) {
  const from = new Date(fromIso);
  const to = new Date(toIso);
  const ms = to.getTime() - from.getTime();
  return Math.round(ms / (1000 * 60 * 60 * 24));
}

function clamp(value: number, min: number, max: number) {
  return Math.max(min, Math.min(max, value));
}

function buildAiEngineSnapshot({
  tasks,
  goals,
  reviews: _reviews,
  lang,
  capacityMinutes,
  minimumSlots,
}: {
  tasks: Task[];
  goals: Goal[];
  reviews: DailyReview[];
  lang: "es" | "en";
  capacityMinutes: number;
  minimumSlots: number;
}): AiEngineSnapshot {
  const todayFull = todayISO();
  const todayKey = todayFull.slice(0, 10);
  const undone = tasks.filter(t => !t.done);

  const stats = {
    totalPending: undone.length,
    highPriority: undone.filter(t => t.priority === "high").length,
    overdue: undone.filter(t => t.dueDate && t.dueDate.slice(0, 10) < todayKey).length,
    capacityMin: capacityMinutes,
    planMinutes: 0,
  };

  const dictionary = lang === "es"
    ? {
        high: "Prioridad alta",
        medium: "Prioridad media",
        dueToday: "Vence hoy",
        dueSoon: (d: number) => `Vence en ${d} día${d === 1 ? "" : "s"}`,
        overdue: (d: number) => `Atraso de ${Math.abs(d)} día${Math.abs(d) === 1 ? "" : "s"}`,
        goalBoost: (project: string) => `Aporta a metas de ${project}`,
        scoreImpact: "Suma a tu score diario",
        suggestedFromGoal: (goal: string) => `Meta "${goal}" necesita movimiento hoy`,
        summaryIntro: (total: number, high: number, overdue: number) =>
          `Tienes ${total} tareas pendientes (${high} críticas, ${overdue} vencidas).`,
        summaryFocus: (titles: string) => `La IA sugiere enfocarte en: ${titles}.`,
        summaryGoals: (goalTitle: string) => `Recuerda empujar la meta "${goalTitle}" hoy mismo.`,
        goalUrgent: (units: number, label: string, date?: string) =>
          date
            ? `Necesitas ${units} ${label} por día para llegar al ${date}.`
            : `Reserva tiempo hoy para avanzar ${units} ${label}.`,
        goalDone: (title: string) => `Meta "${title}" ya completada, celebra y archiva.`,
        goalOverdue: (units: number, label: string) =>
          `Vas retrasado: faltan ${units} ${label}. Recupera hoy.`,
        suggestionOverdue: (count: number) =>
          `Hay ${count} tareas vencidas. Agenda un bloque de recuperación.`,
        suggestionNoGoals: "No has registrado avance en tus metas en los últimos 3 días.",
        suggestionBacklog: "Tu backlog supera tu capacidad diaria. Revisa qué puedes delegar o descartar.",
        suggestionFocus: (project: string) => `Crea una tarea concreta para avanzar ${project} hoy mismo.`,
        aiPlanEmpty: "Sin tareas pendientes. Aprovecha para diseñar nuevas metas.",
      }
    : {
        high: "High priority",
        medium: "Medium priority",
        dueToday: "Due today",
        dueSoon: (d: number) => `Due in ${d} day${d === 1 ? "" : "s"}`,
        overdue: (d: number) => `Overdue by ${Math.abs(d)} day${Math.abs(d) === 1 ? "" : "s"}`,
        goalBoost: (project: string) => `Moves goals in ${project}`,
        scoreImpact: "Boosts your daily score",
        suggestedFromGoal: (goal: string) => `Goal "${goal}" needs action today`,
        summaryIntro: (total: number, high: number, overdue: number) =>
          `You have ${total} pending tasks (${high} critical, ${overdue} overdue).`,
        summaryFocus: (titles: string) => `AI suggests focusing on: ${titles}.`,
        summaryGoals: (goalTitle: string) => `Push goal "${goalTitle}" before the day ends.`,
        goalUrgent: (units: number, label: string, date?: string) =>
          date
            ? `Ship ${units} ${label} per day to hit ${date}.`
            : `Block time today to advance ${units} ${label}.`,
        goalDone: (title: string) => `Goal "${title}" is complete — wrap and archive.`,
        goalOverdue: (units: number, label: string) =>
          `You're late by ${units} ${label}. Recover today.`,
        suggestionOverdue: (count: number) =>
          `${count} tasks are overdue. Schedule a recovery block.`,
        suggestionNoGoals: "No goal progress registered in the last 3 days.",
        suggestionBacklog: "Your backlog exceeds your daily capacity. Decide what to drop or delegate.",
        suggestionFocus: (project: string) => `Create a concrete task to move ${project} forward today.`,
        aiPlanEmpty: "No pending tasks. Design a new challenge.",
      };

  const scoredTasks = undone.map(task => {
    const reasons: string[] = [];
    const priorityBoost = task.priority === "high" ? 60 : task.priority === "med" ? 35 : 15;
    if (task.priority === "high") reasons.push(dictionary.high);
    if (task.priority === "med") reasons.push(dictionary.medium);

    const dueDiff = task.dueDate ? diffDays(todayFull, task.dueDate) : null;
    let dueBoost = 0;
    if (dueDiff !== null) {
      if (dueDiff <= 0) {
        reasons.push(dictionary.dueToday);
        dueBoost = 55 + clamp(Math.abs(dueDiff), 0, 5) * 5;
        if (dueDiff < 0) {
          reasons[reasons.length - 1] = dictionary.overdue(dueDiff);
          dueBoost += 20;
        }
      } else {
        reasons.push(dictionary.dueSoon(dueDiff));
        dueBoost = clamp(45 - dueDiff * 6, 0, 35);
      }
    }

    const ageDays = clamp(diffDays(task.createdAt, todayFull), 0, 60);
    const ageBoost = clamp(ageDays * 0.8, 0, 18);
    const goalBoost = goals.some(g => g.project === task.project) ? 12 : 0;
    if (goalBoost > 0) reasons.push(dictionary.goalBoost(task.project));

    if (reasons.length === 0) reasons.push(dictionary.scoreImpact);

    const score = task.points + priorityBoost + dueBoost + ageBoost + goalBoost;
    return {
      task,
      score,
      reason: reasons.join(" · "),
    };
  });

  const ordered = scoredTasks.sort((a, b) => b.score - a.score);
  const plan: AiPlanItem[] = [];
  let capacityLeft = capacityMinutes;
  for (const entry of ordered) {
    if (plan.length >= minimumSlots && capacityLeft <= 0) break;
    plan.push({
      id: entry.task.id,
      title: entry.task.title,
      project: entry.task.project,
      estimateMin: entry.task.estimateMin,
      reason: entry.reason,
      score: entry.score,
      kind: "existing",
      existingTaskId: entry.task.id,
    });
    capacityLeft -= entry.task.estimateMin;
  }

  stats.planMinutes = plan.reduce((acc, item) => acc + item.estimateMin, 0);

  const commitments: AiGoalPulse[] = goals.map(goal => {
    const totalDone = goal.history.reduce((sum, h) => sum + h.units, 0);
    const remaining = Math.max(0, goal.targetUnits - totalDone);
    const dueDiff = goal.dueDate ? diffDays(todayFull, goal.dueDate) : null;
    const latestHistory = goal.history.reduce<string | undefined>((latest, h) =>
      !latest || h.date > latest ? h.date : latest,
    undefined);

    let urgency: "low" | "medium" | "high" = "low";
    let recommendedUnits = 0;
    let message = "";

    if (remaining <= 0) {
      urgency = "low";
      message = dictionary.goalDone(goal.title);
    } else if (dueDiff !== null && dueDiff < 0) {
      urgency = "high";
      recommendedUnits = remaining;
      message = dictionary.goalOverdue(remaining, goal.unitLabel);
    } else {
      const timeWindow = dueDiff !== null ? Math.max(1, dueDiff) : 5;
      recommendedUnits = Math.max(1, Math.ceil(remaining / timeWindow));
      if (dueDiff !== null) {
        urgency = dueDiff <= 3 ? "high" : dueDiff <= 7 ? "medium" : "low";
        message = dictionary.goalUrgent(
          recommendedUnits,
          goal.unitLabel,
          format(new Date(goal.dueDate!), "dd/MM"),
        );
      } else {
        urgency = latestHistory && diffDays(latestHistory, todayFull) <= 1 ? "medium" : "high";
        message = dictionary.goalUrgent(recommendedUnits, goal.unitLabel);
      }
    }

    return {
      goalId: goal.id,
      goalTitle: goal.title,
      message,
      urgency,
      recommendedUnits,
      unitLabel: goal.unitLabel,
    };
  }).sort((a, b) => {
    const order = { high: 0, medium: 1, low: 2 } as const;
    return order[a.urgency] - order[b.urgency];
  });

  const planProjects = new Set(plan.map(item => item.project));
  const suggestedFromGoals: AiPlanItem[] = [];
  for (const pulse of commitments) {
    if (pulse.urgency === "low") continue;
    const goal = goals.find(g => g.id === pulse.goalId);
    if (!goal) continue;
    const projectHasPending = undone.some(t => t.project === goal.project);
    if (projectHasPending) continue;
    suggestedFromGoals.push({
      id: `suggest-${goal.id}`,
      title: lang === "es"
        ? `Bloque para ${goal.project}: ${pulse.recommendedUnits} ${goal.unitLabel}`
        : `Block for ${goal.project}: ${pulse.recommendedUnits} ${goal.unitLabel}`,
      project: goal.project,
      estimateMin: Math.max(45, pulse.recommendedUnits * 30),
      reason: dictionary.suggestedFromGoal(goal.title),
      score: 40,
      kind: "suggested",
    });
  }

  const combinedPlan = [...plan, ...suggestedFromGoals.slice(0, Math.max(0, minimumSlots - plan.length))];

  const summaryParts: string[] = [];
  summaryParts.push(dictionary.summaryIntro(stats.totalPending, stats.highPriority, stats.overdue));
  const topTitles = plan.slice(0, 3).map(item => item.title).join(lang === "es" ? ", " : ", ");
  if (topTitles) summaryParts.push(dictionary.summaryFocus(topTitles));
  const urgentGoal = commitments.find(c => c.urgency === "high");
  if (urgentGoal) summaryParts.push(dictionary.summaryGoals(urgentGoal.goalTitle));

  const suggestions: AiSuggestion[] = [];
  if (stats.overdue > 0) {
    suggestions.push({ id: "overdue", headline: lang === "es" ? "Recupera vencidas" : "Recover overdue", detail: dictionary.suggestionOverdue(stats.overdue) });
  }

  const threeDaysAgo = new Date(todayFull);
  threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
  const hasRecentGoalProgress = goals.some(goal => goal.history.some(h => new Date(h.date) >= threeDaysAgo));
  if (!hasRecentGoalProgress && goals.length > 0) {
    suggestions.push({ id: "goals", headline: lang === "es" ? "Empuja tus metas" : "Move your goals", detail: dictionary.suggestionNoGoals });
  }

  if (stats.totalPending * 30 > capacityMinutes * 2) {
    suggestions.push({ id: "backlog", headline: lang === "es" ? "Backlog pesado" : "Heavy backlog", detail: dictionary.suggestionBacklog });
  }

  for (const pulse of commitments.filter(c => c.urgency !== "low").slice(0, 2)) {
    if (!planProjects.has(goals.find(g => g.id === pulse.goalId)?.project || "")) {
      const goal = goals.find(g => g.id === pulse.goalId);
      if (goal) {
        suggestions.push({
          id: `goal-${goal.id}`,
          headline: goal.project,
          detail: dictionary.suggestionFocus(goal.project),
        });
      }
    }
  }

  if (stats.totalPending === 0) {
    suggestions.push({ id: "empty", headline: lang === "es" ? "Diseña el siguiente reto" : "Design the next challenge", detail: dictionary.aiPlanEmpty });
  }

  return {
    summary: summaryParts.join(" "),
    stats: { ...stats, planMinutes: combinedPlan.reduce((sum, item) => sum + item.estimateMin, 0) },
    plan: combinedPlan,
    commitments,
    suggestions,
  };
}

// i18n mínimo
const strings = {
  es: {
    title: "Classroom IA · Panel de Ejecución",
    today: "Hoy",
    tasks: "Tareas",
    goals: "Metas",
    review: "Cerrar día",
    week: "Plan semanal",
    backlog: "Backlog",
    focus: "Enfoque",
    settings: "Ajustes",
    templates: "Plantillas",
    dailyScore: "Score diario (últimos 21 días)",
    velocity: "Velocidad por proyecto",
    pending: "Pendientes",
    emptyTasks: "No hay tareas. Qué lujo.",
    newTask: "Nueva tarea",
    newGoal: "Nueva meta",
    activeGoals: "Metas activas",
    closeChecklist: "Checklist de cierre",
    closeHint: "Completa al menos 3 tareas hechas hoy y registra avances en 1 meta. Luego pulsa Calificar día.",
    grade: "Calificar día",
    history: "Histórico",
    due: "Vence",
    project: "Proyecto",
    newProject: "Nuevo proyecto",
    newProjectPrompt: "¿Cómo se llama el nuevo proyecto?",
    estimate: "Estimado (min)",
    points: "Puntos",
    notes: "Notas",
    titleLbl: "Título",
    goalUnits: "Unidades",
    unitLabel: "Etiqueta",
    goalDate: "Fecha objetivo",
    priority: "Prioridad",
    save: "Guardar",
    add: "Agregar",
    create: "Crear",
    send: "Enviar",
    progress: "Progreso",
    eta: "ETA",
    weekPlan: "Plan de la semana",
    todayPlan: "Plan de hoy",
    quickAdd: "Agregar rápido",
    pomodoro: "Pomodoro",
    start: "Iniciar",
    pause: "Pausar",
    reset: "Reiniciar",
    focusBlock: "Bloque de enfoque",
    break: "Descanso",
    light: "Claro",
    dark: "Oscuro",
    language: "Idioma",
    export: "Exportar",
    import: "Importar",
    allowNotif: "Permitir notificaciones",
    aiCoach: "Motor IA",
    aiSummaryTitle: "Diagnóstico del día",
    aiPlanLoad: "Plan sugerido",
    aiCapacityLabel: "Capacidad diaria",
    aiApplyPlan: "Aceptar plan",
    aiReapplyPlan: "Actualizar plan",
    aiPlanApplied: "Plan aplicado",
    aiPlanAppliedHint: "Estas tareas quedaron marcadas como foco del día.",
    aiNoPlan: "La IA necesita tareas activas para construir tu enfoque.",
    aiSuggested: "Sugerido",
    aiFocusBadge: "Foco IA",
    aiGoalPulse: "Pulso de metas",
    aiNoGoals: "Registra una meta para obtener recomendaciones.",
    aiUrgencyHigh: "Alta",
    aiUrgencyMedium: "Media",
    aiUrgencyLow: "Baja",
    aiRecommended: "Recomendado",
    aiSuggestions: "Siguientes movimientos",
    aiNoSuggestions: "Sin recomendaciones adicionales. Sigue ejecutando.",
    aiMinSlotsLabel: "Mínimo de tareas diarias",
    filters: "Filtros",
    allProjects: "Todos los proyectos",
    allPriorities: "Todas las prioridades",
    priorityHigh: "Alta",
    priorityMedium: "Media",
    priorityLow: "Baja",
    searchPlaceholder: "Buscar por título o proyecto",
    showCompleted: "Mostrar completadas",
    showFocusOnly: "Solo foco IA",
    focusAndState: "Estados rápidos",
    clearFilters: "Limpiar filtros",
    filterHint: "Reinicia filtros para visualizar todas tus tareas.",
    bulkTasks: "Cargar tareas en lote",
    bulkHint: "Una por línea: Proyecto | Título | minutos | prioridad (high/med/low).",
    bulkGoals: "Cargar metas en lote",
    bulkGoalHint: "Una por línea: Proyecto | Meta | unidades objetivo | etiqueta.",
    importExample: "Ejemplo",
    edit: "Editar",
    delete: "Eliminar",
    cancel: "Cancelar",
    saveChanges: "Guardar cambios",
    goalProgress: "Avance total",
    historyEntries: "Registro",
    emptyHistory: "Sin registros todavía.",
    removeEntry: "Quitar",
    manageProjects: "Gestionar proyectos",
    manageProjectsHint: "Elimina proyectos que ya no usas. Los elementos activos se enviarán a tu proyecto de soporte.",
    removeProject: "Eliminar proyecto",
    confirmRemoveProject: "Los elementos activos se moverán a tu proyecto de soporte ({count}). ¿Continuar?",
    cannotRemoveDefault: "Los nombres reservados no pueden eliminarse.",
    noCustomProjects: "Aún no tienes proyectos personalizados.",
    confirmDeleteTask: "¿Eliminar esta tarea?",
    confirmDeleteGoal: "¿Eliminar esta meta y su historial?",
    templateProjectLabel: "Aplicar sobre",
    templateIntensity: "Intensidad",
    templateSuccess: "Plantilla cargada. Revisa tus tareas.",
    templateLight: "Ligera",
    templateBalanced: "Balanceada",
    templateTurbo: "Turbo",
    bulkParsed: (count: number) => `${count} elementos añadidos.`,
    priorityPromote: "Priorizar",
    priorityDemote: "Bajar prioridad",
    workspace: "Workspace",
    workspacePages: "Páginas inteligentes",
    workspaceSidebarHint: "Diseña vistas al estilo Notion para aterrizar tus objetivos diarios o proyectos.",
    workspaceNewPage: "Nueva página",
    workspaceTemplates: "Plantillas rápidas",
    workspaceTemplateDailyName: "Agenda diaria",
    workspaceTemplateProjectName: "Proyecto",
    workspaceTemplateKnowledgeName: "Laboratorio",
    workspaceTemplateBlankName: "Página en blanco",
    workspaceTemplateBlankTitle: "Página en blanco",
    workspaceTemplateBlankDescription: "Comienza desde cero con un lienzo limpio.",
    workspaceTemplateDailyTitle: "Agenda de ejecución diaria",
    workspaceTemplateDailyDescription: "Alinea foco, checklist de mínimos y reflexiones del día.",
    workspaceTemplateProjectTitle: "Tablero de proyecto",
    workspaceTemplateProjectDescription: "Visualiza el norte, hitos y recursos clave de un proyecto.",
    workspaceTemplateKnowledgeTitle: "Laboratorio de ideas",
    workspaceTemplateKnowledgeDescription: "Centraliza preguntas, hallazgos y referencias de investigación.",
    workspaceDuplicateSuffix: "copia",
    workspaceSearchPlaceholder: "Buscar páginas o etiquetas",
    workspaceFilterAll: "Todas las etiquetas",
    workspaceTagsLabel: "Etiquetas",
    workspaceEmpty: "No hay páginas todavía.",
    workspaceCreateFirst: "Crea una página para diseñar tu sistema.",
    workspaceFavorite: "Favorita",
    workspaceFavoriteTooltip: "Marcar como favorita",
    workspaceLastEdited: "Actualizada",
    workspaceTitlePlaceholder: "Página sin título",
    workspaceDescriptionPlaceholder: "Describe el propósito o el resultado deseado",
    workspaceTagsPlaceholder: "Ej. focus, universidad",
    workspaceIconLabel: "Icono",
    workspaceColorLabel: "Color",
    workspaceActions: "Acciones",
    workspaceDuplicate: "Duplicar",
    workspaceDelete: "Eliminar",
    workspaceDeleteConfirm: "¿Eliminar esta página? Perderás sus bloques.",
    workspaceAddBlock: "Agregar bloque",
    workspaceAddHeading: "Encabezado",
    workspaceAddTodo: "Checklist",
    workspaceAddText: "Nota",
    workspaceAddDivider: "Separador",
    workspaceNoBlocks: "Añade bloques para estructurar esta página.",
    workspaceChangeAccent: "Cambiar acento",
    workspaceBlockToday: "Victoria de hoy",
    workspaceBlockDailyFocus: "Bloque crítico del día",
    workspaceBlockDailySecondary: "Segundo empuje",
    workspaceBlockSharpen: "Cierre / aprendizaje clave",
    workspaceBlockHighlights: "Highlights",
    workspaceBlockHighlightsHint: "Resume logros, aprendizajes y pendientes rápidos.",
    workspaceBlockNorthStar: "North Star",
    workspaceBlockNorthStarHint: "Define qué impacto buscas lograr con este proyecto.",
    workspaceBlockRoadmap: "Roadmap inmediato",
    workspaceBlockMilestoneOne: "Hito 1 listo",
    workspaceBlockMilestoneTwo: "Hito 2 encaminado",
    workspaceBlockMilestoneThree: "Hito 3 desbloqueado",
    workspaceBlockResources: "Recursos & enlaces",
    workspaceBlockResourcesHint: "Pega referencias, briefs y documentos críticos.",
    workspaceBlockQuestions: "Preguntas guía",
    workspaceBlockQuestionsHint: "Qué necesitas comprender o validar con esta investigación.",
    workspaceBlockIdeas: "Ideas en progreso",
    workspaceBlockIdeasHint: "Captura hipótesis, conceptos y experimentos en curso.",
    workspaceBlockReferences: "Referencias",
    workspaceBlockReferencesHint: "Guarda lecturas, videos y contactos clave.",
    workspaceBlockBlankHeading: "Nuevo bloque",
    workspaceBlockBlankHint: "Agrega texto, checklist o encabezados para darle forma.",
    workspaceBlockNewHeading: "Nuevo encabezado",
    workspaceBlockNewTodo: "Nueva tarea",
    workspaceBlockNewText: "Nuevo texto",
    workspaceDividerLabel: "Separador",
    calendar: "Calendario",
    calendarHeading: "Google Calendar",
    calendarIntro: "Sincroniza tus eventos para planear alrededor de compromisos reales.",
    calendarStatus: "Estado",
    calendarStatusReadyHint: "Listo para conectar",
    calendarStatusIdle: "Desconectado",
    calendarStatusLoading: "Sincronizando…",
    calendarStatusConnected: "Conectado",
    calendarStatusError: "Error",
    calendarReady: "API cargada",
    calendarNotReady: "Esperando a Google",
    calendarConnect: "Conectar con Google",
    calendarRefresh: "Actualizar eventos",
    calendarDisconnect: "Desconectar",
    calendarConfigTitle: "Credenciales",
    calendarApiKey: "API key",
    calendarClientId: "Client ID de OAuth",
    calendarCalendarId: "ID de calendario",
    calendarTimezone: "Zona horaria",
    calendarLookAhead: "Ventana",
    calendarLookAheadSuffix: "días",
    calendarHint: "Usa credenciales OAuth de tipo web (https://developers.google.com/calendar) y habilita Calendar API.",
    calendarInstructions: "Al conectar, los eventos próximos aparecerán aquí con horarios y enlaces.",
    calendarUpcoming: "Eventos próximos",
    calendarNoEvents: "No hay eventos en la ventana seleccionada.",
    calendarLastSync: "Última sincronización",
    calendarSignedInAs: "Sesión iniciada como",
    calendarOpenEvent: "Abrir en Google Calendar",
    calendarEventAllDay: "Todo el día",
    calendarManualLink: "Guía de credenciales",
    calendarStatusNoApi: "No pudimos cargar el cliente de Google. Revisa tu conexión o bloqueadores.",
    calendarConnecting: "Conectando con Google…",
    calendarAuthRequired: "Inicia sesión para poder leer tu calendario.",
    calendarUntitled: "(sin título)",
    calendarSyncedAt: "Sincronizado a las {time}",
    calendarUnknownError: "Ocurrió un error inesperado al sincronizar.",
    calendarDisconnected: "Desconectado.",
    defaultProjectName: "Proyecto principal",
    supportProjectName: "Operaciones",
    interfaceStyle: "Estilo visual",
    cardStyleLabel: "Superficie",
    cardStyleGlass: "Cristal",
    cardStyleSolid: "Sólido",
    cardStyleGradient: "Degradado",
    cardShadowLabel: "Sombra",
    shadowSoft: "Suave",
    shadowMedium: "Media",
    shadowBold: "Intensa",
    cardRadiusLabel: "Bordes",
    radiusMd: "Suave",
    radiusLg: "Redondeado",
    radiusXl: "Orgánico",
    accentPalette: "Paleta",
    accentEmerald: "Esmeralda",
    accentViolet: "Violeta",
    accentAmber: "Ámbar",
    accentSky: "Cian",
    accentSlate: "Pizarra",
    densityLabel: "Densidad",
    densityComfortable: "Amplio",
    densityCozy: "Acogedor",
    densityCompact: "Compacto",
    fieldStyleLabel: "Campos",
    fieldGlassy: "Cristalinos",
    fieldSolid: "Sólidos",
    fieldMinimal: "Minimalistas",
    defaultProjectLabel: "Nombre para proyecto base",
    supportProjectLabel: "Nombre para soporte",
    dialogBlur: "Desenfoque de diálogos",
    dialogToneLabel: "Tono de diálogos",
    dialogToneNeutral: "Neutro",
    dialogToneAccent: "Acentuado",
    dialogToneInverted: "Invertido",
    chatbot: "Chatbot",
    chatbotTitle: "Asistente de proyectos",
    chatbotIntro: "Pregunta por prioridades, fechas límite o llama a un proyecto por su nombre para ver su estado.",
    chatbotPlaceholder: "Describe qué necesitas desbloquear…",
    chatbotEmpty: "Aún no hay conversación. Pregunta qué conviene atacar primero.",
    chatbotThinking: "Analizando tus proyectos…",
    chatbotGreet: "Listo para ayudarte a planear el día. ¿Qué quieres lograr?",
    chatbotNoData: "Registra tareas o metas para que pueda orientarte.",
  },
  en: {
    title: "AI Classroom · Execution Panel",
    today: "Today",
    tasks: "Tasks",
    goals: "Goals",
    review: "Daily review",
    week: "Weekly plan",
    backlog: "Backlog",
    focus: "Focus",
    settings: "Settings",
    templates: "Templates",
    dailyScore: "Daily score (last 21 days)",
    velocity: "Velocity by project",
    pending: "Pending",
    emptyTasks: "No tasks. Must be nice.",
    newTask: "New task",
    newGoal: "New goal",
    activeGoals: "Active goals",
    closeChecklist: "Day checklist",
    closeHint: "Complete at least 3 tasks done today and log progress in 1 goal, then grade.",
    grade: "Grade day",
    history: "History",
    due: "Due",
    project: "Project",
    newProject: "New project",
    newProjectPrompt: "Name of the new project",
    estimate: "Estimate (min)",
    points: "Points",
    notes: "Notes",
    titleLbl: "Title",
    goalUnits: "Units",
    unitLabel: "Unit label",
    goalDate: "Target date",
    priority: "Priority",
    save: "Save",
    add: "Add",
    create: "Create",
    send: "Send",
    progress: "Progress",
    eta: "ETA",
    weekPlan: "Weekly plan",
    todayPlan: "Today plan",
    quickAdd: "Quick add",
    pomodoro: "Pomodoro",
    start: "Start",
    pause: "Pause",
    reset: "Reset",
    focusBlock: "Focus block",
    break: "Break",
    light: "Light",
    dark: "Dark",
    language: "Language",
    export: "Export",
    import: "Import",
    allowNotif: "Allow notifications",
    aiCoach: "AI coach",
    aiSummaryTitle: "Daily diagnosis",
    aiPlanLoad: "Suggested plan",
    aiCapacityLabel: "Daily capacity",
    aiApplyPlan: "Adopt plan",
    aiReapplyPlan: "Refresh plan",
    aiPlanApplied: "Plan locked",
    aiPlanAppliedHint: "These tasks are now tagged as today's focus.",
    aiNoPlan: "The assistant needs active tasks to build your focus.",
    aiSuggested: "Suggested",
    aiFocusBadge: "AI Focus",
    aiGoalPulse: "Goal pulse",
    aiNoGoals: "Add a goal to get tailored nudges.",
    aiUrgencyHigh: "High",
    aiUrgencyMedium: "Medium",
    aiUrgencyLow: "Low",
    aiRecommended: "Recommended",
    aiSuggestions: "Next moves",
    aiNoSuggestions: "No extra recommendations. Keep shipping.",
    aiMinSlotsLabel: "Minimum daily tasks",
    filters: "Filters",
    allProjects: "All projects",
    allPriorities: "All priorities",
    priorityHigh: "High",
    priorityMedium: "Medium",
    priorityLow: "Low",
    searchPlaceholder: "Search title or project",
    showCompleted: "Show completed",
    showFocusOnly: "AI focus only",
    focusAndState: "Quick states",
    clearFilters: "Clear filters",
    filterHint: "Reset filters to see every task again.",
    bulkTasks: "Bulk add tasks",
    bulkHint: "One per line: Project | Title | minutes | priority (high/med/low).",
    bulkGoals: "Bulk add goals",
    bulkGoalHint: "One per line: Project | Goal | target units | unit label.",
    importExample: "Example",
    edit: "Edit",
    delete: "Delete",
    cancel: "Cancel",
    saveChanges: "Save changes",
    goalProgress: "Total progress",
    historyEntries: "Log",
    emptyHistory: "No entries yet.",
    removeEntry: "Remove",
    manageProjects: "Manage projects",
    manageProjectsHint: "Remove projects you no longer use. Active items move to your support project.",
    removeProject: "Remove project",
    confirmRemoveProject: "Active items will move to your support project ({count}). Continue?",
    cannotRemoveDefault: "Reserved names cannot be removed.",
    noCustomProjects: "No custom projects yet.",
    confirmDeleteTask: "Delete this task?",
    confirmDeleteGoal: "Delete this goal and its history?",
    templateProjectLabel: "Apply to",
    templateIntensity: "Intensity",
    templateSuccess: "Template loaded. Review your board.",
    templateLight: "Light",
    templateBalanced: "Balanced",
    templateTurbo: "Turbo",
    bulkParsed: (count: number) => `${count} items added.`,
    priorityPromote: "Promote",
    priorityDemote: "Lower priority",
    workspace: "Workspace",
    workspacePages: "Smart pages",
    workspaceSidebarHint: "Craft Notion-style views to anchor your focus, goals, and projects.",
    workspaceNewPage: "New page",
    workspaceTemplates: "Quick templates",
    workspaceTemplateDailyName: "Daily agenda",
    workspaceTemplateProjectName: "Project",
    workspaceTemplateKnowledgeName: "Lab",
    workspaceTemplateBlankName: "Blank page",
    workspaceTemplateBlankTitle: "Blank page",
    workspaceTemplateBlankDescription: "Start with a clean canvas and build your own blocks.",
    workspaceTemplateDailyTitle: "Daily execution agenda",
    workspaceTemplateDailyDescription: "Align focus, minimum checklist, and end-of-day reflections.",
    workspaceTemplateProjectTitle: "Project command board",
    workspaceTemplateProjectDescription: "Surface the north star, key milestones, and critical resources.",
    workspaceTemplateKnowledgeTitle: "Idea lab",
    workspaceTemplateKnowledgeDescription: "Centralize guiding questions, findings, and references.",
    workspaceDuplicateSuffix: "copy",
    workspaceSearchPlaceholder: "Search pages or tags",
    workspaceFilterAll: "All tags",
    workspaceTagsLabel: "Tags",
    workspaceEmpty: "No pages yet.",
    workspaceCreateFirst: "Spin up a page to design your system.",
    workspaceFavorite: "Favorite",
    workspaceFavoriteTooltip: "Mark as favorite",
    workspaceLastEdited: "Updated",
    workspaceTitlePlaceholder: "Untitled page",
    workspaceDescriptionPlaceholder: "Describe the purpose or desired outcome",
    workspaceTagsPlaceholder: "e.g. focus, university",
    workspaceIconLabel: "Icon",
    workspaceColorLabel: "Color",
    workspaceActions: "Actions",
    workspaceDuplicate: "Duplicate",
    workspaceDelete: "Delete",
    workspaceDeleteConfirm: "Delete this page? Blocks will be removed as well.",
    workspaceAddBlock: "Add block",
    workspaceAddHeading: "Heading",
    workspaceAddTodo: "Checklist",
    workspaceAddText: "Note",
    workspaceAddDivider: "Divider",
    workspaceNoBlocks: "Add blocks to structure this page.",
    workspaceChangeAccent: "Change accent",
    workspaceBlockToday: "Win of the day",
    workspaceBlockDailyFocus: "Critical focus block",
    workspaceBlockDailySecondary: "Second push",
    workspaceBlockSharpen: "Sharpen / key learning",
    workspaceBlockHighlights: "Highlights",
    workspaceBlockHighlightsHint: "Capture wins, insights, and quick follow-ups.",
    workspaceBlockNorthStar: "North star",
    workspaceBlockNorthStarHint: "Clarify the impact this project should deliver.",
    workspaceBlockRoadmap: "Immediate roadmap",
    workspaceBlockMilestoneOne: "Milestone 1 delivered",
    workspaceBlockMilestoneTwo: "Milestone 2 in motion",
    workspaceBlockMilestoneThree: "Milestone 3 unlocked",
    workspaceBlockResources: "Resources & links",
    workspaceBlockResourcesHint: "Drop references, briefs, and critical docs.",
    workspaceBlockQuestions: "Guiding questions",
    workspaceBlockQuestionsHint: "What do you need to validate or understand?",
    workspaceBlockIdeas: "Ideas in progress",
    workspaceBlockIdeasHint: "Capture hypotheses, concepts, and experiments.",
    workspaceBlockReferences: "References",
    workspaceBlockReferencesHint: "Store readings, videos, and key contacts.",
    workspaceBlockBlankHeading: "New block",
    workspaceBlockBlankHint: "Add text, checklists, or headings to shape the page.",
    workspaceBlockNewHeading: "New heading",
    workspaceBlockNewTodo: "New task",
    workspaceBlockNewText: "New text",
    workspaceDividerLabel: "Divider",
    calendar: "Calendar",
    calendarHeading: "Google Calendar",
    calendarIntro: "Sync your events so the planner adapts to real commitments.",
    calendarStatus: "Status",
    calendarStatusReadyHint: "Ready to connect",
    calendarStatusIdle: "Disconnected",
    calendarStatusLoading: "Syncing…",
    calendarStatusConnected: "Connected",
    calendarStatusError: "Error",
    calendarReady: "API loaded",
    calendarNotReady: "Waiting for Google",
    calendarConnect: "Connect Google",
    calendarRefresh: "Refresh events",
    calendarDisconnect: "Disconnect",
    calendarConfigTitle: "Credentials",
    calendarApiKey: "API key",
    calendarClientId: "OAuth client ID",
    calendarCalendarId: "Calendar ID",
    calendarTimezone: "Time zone",
    calendarLookAhead: "Window",
    calendarLookAheadSuffix: "days",
    calendarHint: "Use a web OAuth client with Calendar API enabled (https://developers.google.com/calendar).",
    calendarInstructions: "After connecting you'll see upcoming events with rich details.",
    calendarUpcoming: "Upcoming events",
    calendarNoEvents: "No events in the selected window.",
    calendarLastSync: "Last sync",
    calendarSignedInAs: "Signed in as",
    calendarOpenEvent: "Open in Google Calendar",
    calendarEventAllDay: "All day",
    calendarManualLink: "Credential guide",
    calendarStatusNoApi: "We couldn't load the Google client. Check your connection or blockers.",
    calendarConnecting: "Connecting to Google…",
    calendarAuthRequired: "Sign in to read your calendar.",
    calendarUntitled: "(untitled)",
    calendarSyncedAt: "Synced at {time}",
    calendarUnknownError: "Something went wrong while syncing.",
    calendarDisconnected: "Disconnected.",
    defaultProjectName: "Main project",
    supportProjectName: "Support",
    interfaceStyle: "Visual style",
    cardStyleLabel: "Surface",
    cardStyleGlass: "Glass",
    cardStyleSolid: "Solid",
    cardStyleGradient: "Gradient",
    cardRadiusLabel: "Corners",
    radiusMd: "Soft",
    radiusLg: "Rounded",
    radiusXl: "Organic",
    accentPalette: "Palette",
    accentEmerald: "Emerald",
    accentViolet: "Violet",
    accentAmber: "Amber",
    accentSky: "Sky",
    accentSlate: "Slate",
    densityLabel: "Density",
    densityComfortable: "Roomy",
    densityCozy: "Cozy",
    densityCompact: "Compact",
    cardShadowLabel: "Shadow",
    shadowSoft: "Soft",
    shadowMedium: "Medium",
    shadowBold: "Bold",
    fieldStyleLabel: "Fields",
    fieldGlassy: "Glass",
    fieldSolid: "Solid",
    fieldMinimal: "Minimal",
    defaultProjectLabel: "Default project name",
    supportProjectLabel: "Support project name",
    dialogBlur: "Dialog blur",
    dialogToneLabel: "Dialog tone",
    dialogToneNeutral: "Neutral",
    dialogToneAccent: "Accent",
    dialogToneInverted: "Inverted",
    chatbot: "Chatbot",
    chatbotTitle: "Project assistant",
    chatbotIntro: "Ask about priorities, deadlines, or mention a project by name to inspect its status.",
    chatbotPlaceholder: "Tell me what you need to unblock…",
    chatbotEmpty: "No conversation yet. Ask what deserves attention first.",
    chatbotThinking: "Reviewing your projects…",
    chatbotGreet: "Ready to help plan your day. What's the goal?",
    chatbotNoData: "Add tasks or goals so I can guide you.",
  }
} as const;

// ============== Componente Principal ==============
export default function Dashboard() {
  // estado
  const [goals, setGoals] = useState<Goal[]>(() => loadLS<Goal[]>(LS_KEYS.goals, []));
  const [tasks, setTasks] = useState<Task[]>(() => loadLS<Task[]>(LS_KEYS.tasks, []));
  const [reviews, setReviews] = useState<DailyReview[]>(() => loadLS<DailyReview[]>(LS_KEYS.reviews, []));
  const [cfg, setCfg] = useState<Cfg>(() => ({ ...DEFAULT_CFG, ...loadLS<Cfg>(LS_KEYS.cfg, DEFAULT_CFG) }));
  const [projects, setProjects] = useState<string[]>(() => loadLS<string[]>(LS_KEYS.projects, DEFAULT_PROJECTS));
  const [uiPrefs, setUiPrefs] = useState<UiPreferences>(() => ({
    ...DEFAULT_UI_PREFS,
    ...loadLS<UiPreferences>(LS_KEYS.uiPrefs, DEFAULT_UI_PREFS),
  }));
  const [aiFocus, setAiFocus] = useState<AiFocusState>(() => {
    const today = todayISO().slice(0, 10);
    const stored = loadLS<AiFocusState>(LS_KEYS.focus, { date: today, taskIds: [] });
    if (!stored || stored.date !== today) return { date: today, taskIds: [] };
    return stored;
  });
  const [taskProjectFilter, setTaskProjectFilter] = useState<string>("all");
  const [taskPriorityFilter, setTaskPriorityFilter] = useState<string>("all");
  const [taskSearch, setTaskSearch] = useState("");
  const [showCompletedTasks, setShowCompletedTasks] = useState(false);
  const [focusOnly, setFocusOnly] = useState(false);
  const [editingTask, setEditingTask] = useState<Task | null>(null);
  const [editingGoal, setEditingGoal] = useState<Goal | null>(null);
  const workspaceSeed = useMemo<WorkspacePage[]>(() => {
    const stored = loadLS<WorkspacePage[]>(LS_KEYS.workspace, []);
    if (stored.length) return stored;
    return createDefaultWorkspacePages();
  }, []);
  const [workspacePages, setWorkspacePages] = useState<WorkspacePage[]>(workspaceSeed);
  const [activeWorkspacePageId, setActiveWorkspacePageId] = useState<string>(() => {
    const stored = loadLS<string | null>(LS_KEYS.workspaceActive, null);
    return stored || workspaceSeed[0]?.id || "";
  });
  const [gcalConfig, setGcalConfig] = useState<GoogleCalendarConfig>(() => ({
    ...DEFAULT_GCAL_CFG,
    ...loadLS<GoogleCalendarConfig>(LS_KEYS.gcalCfg, DEFAULT_GCAL_CFG),
  }));
  const [gcalState, setGcalState] = useState<GoogleCalendarState>(() => {
    const stored = loadLS<GoogleCalendarState>(LS_KEYS.gcalState, { status: "idle", events: [] });
    return {
      status: stored.status ?? "idle",
      message: stored.message,
      events: Array.isArray(stored.events) ? stored.events : [],
      profile: stored.profile,
      lastSyncedAt: stored.lastSyncedAt,
    };
  });
  const [gapiReady, setGapiReady] = useState(false);
  const gapiScriptLoaded = useRef(false);

  // Persistencia automática
  useEffect(() => saveLS(LS_KEYS.goals, goals), [goals]);
  useEffect(() => saveLS(LS_KEYS.tasks, tasks), [tasks]);
  useEffect(() => saveLS(LS_KEYS.reviews, reviews), [reviews]);
  useEffect(() => saveLS(LS_KEYS.cfg, cfg), [cfg]);
  useEffect(() => saveLS(LS_KEYS.projects, projects), [projects]);
  useEffect(() => saveLS(LS_KEYS.focus, aiFocus), [aiFocus]);
  useEffect(() => saveLS(LS_KEYS.workspace, workspacePages), [workspacePages]);
  useEffect(() => saveLS(LS_KEYS.uiPrefs, uiPrefs), [uiPrefs]);
  useEffect(() => {
    if (activeWorkspacePageId) {
      saveLS(LS_KEYS.workspaceActive, activeWorkspacePageId);
    }
  }, [activeWorkspacePageId]);
  useEffect(() => saveLS(LS_KEYS.gcalCfg, gcalConfig), [gcalConfig]);
  useEffect(() => saveLS(LS_KEYS.gcalState, gcalState), [gcalState]);

  useEffect(() => {
    const today = todayISO().slice(0, 10);
    setAiFocus(prev => (prev.date === today ? prev : { date: today, taskIds: [], summary: undefined }));
  }, []);

  useEffect(() => {
    const today = todayISO().slice(0, 10);
    if (aiFocus.date !== today && focusOnly) {
      setFocusOnly(false);
    }
  }, [aiFocus, focusOnly]);

  useEffect(() => {
    if (!workspacePages.length) {
      const defaults = createDefaultWorkspacePages();
      if (defaults.length) {
        setWorkspacePages(defaults);
        setActiveWorkspacePageId(defaults[0]?.id || "");
      }
      return;
    }
    if (!activeWorkspacePageId || !workspacePages.some(page => page.id === activeWorkspacePageId)) {
      setActiveWorkspacePageId(workspacePages[0]?.id || "");
    }
  }, [workspacePages, activeWorkspacePageId]);

  useEffect(() => {
    if (typeof window === "undefined") return;
    if (gapiScriptLoaded.current && (window as any).gapi) {
      setGapiReady(true);
      return;
    }
    if (document.querySelector('script[data-google-api="true"]')) {
      gapiScriptLoaded.current = true;
      if ((window as any).gapi) {
        setGapiReady(true);
      }
      return;
    }
    const script = document.createElement("script");
    script.src = "https://apis.google.com/js/api.js";
    script.async = true;
    script.defer = true;
    script.dataset.googleApi = "true";
    script.onload = () => {
      gapiScriptLoaded.current = true;
      setGapiReady(true);
    };
    script.onerror = () => {
      gapiScriptLoaded.current = true;
      setGapiReady(false);
      setGcalState(prev => ({
        ...prev,
        status: prev.status === "connected" ? prev.status : "error",
        message: prev.message || "No se pudo cargar Google API",
      }));
    };
    document.body.appendChild(script);
  }, [setGcalState]);

  const registerProject = useCallback((name: string) => {
    const trimmed = name.trim();
    if (!trimmed) return;
    const normalized = trimmed.toLocaleLowerCase();
    setProjects(prev => {
      if (prev.some(p => p.toLocaleLowerCase() === normalized)) {
        return prev;
      }
      const set = new Set<string>(prev.filter(Boolean));
      set.add(trimmed);
      const next = Array.from(set).sort((a, b) => a.localeCompare(b, cfg.lang, { sensitivity: "base" }));
      return next;
    });
  }, [cfg.lang]);

  useEffect(() => {
    setProjects(prev => {
      const set = new Set<string>(prev.filter(Boolean));
      goals.forEach(g => g.project && set.add(g.project));
      tasks.forEach(t => t.project && set.add(t.project));
      const next = Array.from(set).sort((a, b) => a.localeCompare(b, cfg.lang, { sensitivity: "base" }));
      if (next.length === prev.length && next.every((value, index) => value === prev[index])) {
        return prev;
      }
      return next;
    });
  }, [goals, tasks, cfg.lang]);

  // Tema
  useEffect(() => {
    document.documentElement.classList.toggle("dark", cfg.theme === "dark");
  }, [cfg.theme]);

  // ====== Derivados ======
  const t = strings[cfg.lang];
  const defaultProjectName = uiPrefs.defaultProjectName.trim() || t.defaultProjectName;
  const supportProjectName = uiPrefs.supportProjectName.trim() || t.supportProjectName;
  const effectiveProjects = useMemo(() => {
    const set = new Set<string>();
    projects.forEach(name => {
      if (name) set.add(name);
    });
    if (defaultProjectName) set.add(defaultProjectName);
    if (supportProjectName) set.add(supportProjectName);
    return Array.from(set).sort((a, b) => a.localeCompare(b, cfg.lang, { sensitivity: "base" }));
  }, [projects, defaultProjectName, supportProjectName, cfg.lang]);
  const todayKey = todayISO().slice(0, 10);
  const defaultProject = effectiveProjects[0] ?? defaultProjectName;
  const focusTodayIds = useMemo(() => new Set(aiFocus.date === todayKey ? aiFocus.taskIds : []), [aiFocus, todayKey]);

  const surfaceTokens = useMemo<SurfaceTokens>(() => {
    const accentMap = {
      emerald: {
        ring: "ring-emerald-400/60",
        soft: "bg-emerald-500/10 dark:bg-emerald-500/15",
        gradient: "from-emerald-300/40 via-emerald-500/20",
      },
      violet: {
        ring: "ring-violet-400/60",
        soft: "bg-violet-500/10 dark:bg-violet-500/15",
        gradient: "from-violet-300/40 via-violet-500/20",
      },
      amber: {
        ring: "ring-amber-400/60",
        soft: "bg-amber-500/15 dark:bg-amber-500/20",
        gradient: "from-amber-300/40 via-amber-500/25",
      },
      sky: {
        ring: "ring-sky-400/60",
        soft: "bg-sky-500/10 dark:bg-sky-500/15",
        gradient: "from-sky-300/40 via-sky-500/20",
      },
      slate: {
        ring: "ring-slate-400/60",
        soft: "bg-slate-500/10 dark:bg-slate-500/15",
        gradient: "from-slate-300/40 via-slate-500/20",
      },
    } as const;

    const accent = accentMap[uiPrefs.accent];
    const radiusClass = uiPrefs.cardRadius === "md" ? "rounded-xl" : uiPrefs.cardRadius === "lg" ? "rounded-2xl" : "rounded-3xl";
    const baseInteractive = "transition-all duration-300";
    const shadowMap = {
      soft: "shadow-md",
      medium: "shadow-xl",
      bold:
        uiPrefs.accent === "emerald"
          ? "shadow-[0_28px_48px_-28px_rgba(16,185,129,0.55)]"
          : uiPrefs.accent === "violet"
          ? "shadow-[0_28px_48px_-28px_rgba(139,92,246,0.55)]"
          : uiPrefs.accent === "amber"
          ? "shadow-[0_28px_48px_-30px_rgba(251,191,36,0.55)]"
          : uiPrefs.accent === "sky"
          ? "shadow-[0_28px_48px_-28px_rgba(14,165,233,0.55)]"
          : "shadow-[0_28px_48px_-28px_rgba(100,116,139,0.55)]",
    } as const;

    const hoverMap = {
      soft: "hover:shadow-lg",
      medium: "hover:shadow-2xl",
      bold:
        uiPrefs.accent === "emerald"
          ? "hover:shadow-[0_36px_68px_-32px_rgba(16,185,129,0.6)]"
          : uiPrefs.accent === "violet"
          ? "hover:shadow-[0_36px_68px_-32px_rgba(139,92,246,0.6)]"
          : uiPrefs.accent === "amber"
          ? "hover:shadow-[0_36px_68px_-34px_rgba(251,191,36,0.6)]"
          : uiPrefs.accent === "sky"
          ? "hover:shadow-[0_36px_68px_-32px_rgba(14,165,233,0.6)]"
          : "hover:shadow-[0_36px_68px_-32px_rgba(100,116,139,0.6)]",
    } as const;

    const cardSurface =
      uiPrefs.cardStyle === "glass"
        ? "border border-white/30 bg-white/60 backdrop-blur-xl dark:border-white/10 dark:bg-neutral-900/60"
        : uiPrefs.cardStyle === "solid"
        ? "border border-neutral-200 bg-white dark:border-neutral-800 dark:bg-neutral-950"
        : cx(`bg-gradient-to-br ${accent.gradient} to-white/85 dark:to-neutral-950/90`, "border border-white/10 dark:border-white/5");

    const dialogTone =
      uiPrefs.dialogTone === "neutral"
        ? "border border-neutral-200/70 bg-white/94 shadow-2xl dark:border-neutral-800/70 dark:bg-neutral-950/95"
        : uiPrefs.dialogTone === "accent"
        ? cx(`border border-white/15 bg-gradient-to-br ${accent.gradient} to-white/92 dark:to-neutral-950/92`, "shadow-2xl")
        : "border border-neutral-900/70 bg-neutral-950/95 text-neutral-100 shadow-2xl dark:border-neutral-100/10";

    const fieldBase = "px-3 py-2 text-sm transition focus-visible:ring-2 focus-visible:ring-offset-0 focus-visible:outline-none";
    const field = cx(
      fieldBase,
      uiPrefs.fieldStyle === "glassy"
        ? "rounded-xl border border-white/40 bg-white/40 backdrop-blur dark:border-white/10 dark:bg-white/10 text-neutral-900 placeholder:text-neutral-500 dark:text-neutral-100 dark:placeholder:text-neutral-400"
        : uiPrefs.fieldStyle === "solid"
        ? "rounded-xl border border-neutral-200 bg-white text-neutral-900 placeholder:text-neutral-500 dark:border-neutral-700 dark:bg-neutral-900 dark:text-neutral-100 dark:placeholder:text-neutral-400"
        : "rounded-xl border border-transparent bg-transparent text-neutral-900 placeholder:text-neutral-500 focus-visible:ring-neutral-400/70 dark:text-neutral-100 dark:placeholder:text-neutral-400 dark:focus-visible:ring-neutral-500/60",
    );

    const fieldArea = cx(
      "px-4 py-3 text-sm transition focus-visible:ring-2 focus-visible:ring-offset-0 focus-visible:outline-none",
      uiPrefs.fieldStyle === "glassy"
        ? "rounded-2xl border border-white/35 bg-white/35 backdrop-blur dark:border-white/10 dark:bg-white/10 text-neutral-900 placeholder:text-neutral-500 dark:text-neutral-100"
        : uiPrefs.fieldStyle === "solid"
        ? "rounded-2xl border border-neutral-200 bg-white text-neutral-900 placeholder:text-neutral-500 dark:border-neutral-700 dark:bg-neutral-900 dark:text-neutral-100"
        : "rounded-2xl border border-neutral-200/30 bg-transparent text-neutral-900 placeholder:text-neutral-500 focus-visible:ring-neutral-400/70 dark:border-neutral-700/40 dark:text-neutral-100",
    );

    const subtle =
      uiPrefs.cardStyle === "solid"
        ? "border border-neutral-200/70 bg-white/80 dark:border-neutral-700/60 dark:bg-neutral-900/60"
        : uiPrefs.cardStyle === "gradient"
        ? cx(`border border-white/20 bg-gradient-to-br ${accent.gradient} to-white/30 dark:to-neutral-900/50 backdrop-blur`)
        : "border border-white/25 bg-white/30 backdrop-blur-lg dark:border-white/10 dark:bg-neutral-900/45";

    const hover = cx(
      baseInteractive,
      hoverMap[uiPrefs.cardShadow],
      "hover:-translate-y-0.5",
    );

    return {
      card: cx(radiusClass, cardSurface, shadowMap[uiPrefs.cardShadow], baseInteractive),
      dialog: cx(radiusClass, dialogTone),
      dialogStyle: { backdropFilter: `blur(${uiPrefs.dialogBlur}px)` },
      accentRing: accent.ring,
      accentSoft: accent.soft,
      hover,
      subtle,
      field,
      fieldArea,
      density: uiPrefs.density,
      accentName: uiPrefs.accent,
    };
  }, [uiPrefs]);

  useEffect(() => {
    if (taskProjectFilter !== "all" && !effectiveProjects.includes(taskProjectFilter)) {
      setTaskProjectFilter("all");
    }
  }, [effectiveProjects, taskProjectFilter]);
  const activeWorkspacePage = useMemo(() => {
    if (!workspacePages.length) return null;
    return workspacePages.find(page => page.id === activeWorkspacePageId) ?? workspacePages[0];
  }, [workspacePages, activeWorkspacePageId]);
  const priorityOrder: Record<Task["priority"], number> = { high: 0, med: 1, low: 2 };
  const visibleTasks = useMemo(() => {
    const normalized = taskSearch.trim().toLowerCase();
    return tasks
      .filter(task => (showCompletedTasks ? true : !task.done))
      .filter(task => (taskProjectFilter === "all" ? true : task.project === taskProjectFilter))
      .filter(task => (taskPriorityFilter === "all" ? true : task.priority === taskPriorityFilter))
      .filter(task => (!focusOnly ? true : focusTodayIds.has(task.id)))
      .filter(task => {
        if (!normalized) return true;
        return `${task.title} ${task.project}`.toLowerCase().includes(normalized);
      })
      .sort((a, b) => {
        if (a.done !== b.done) return a.done ? 1 : -1;
        const dueA = a.dueDate ? a.dueDate.slice(0, 10) : "9999-12-31";
        const dueB = b.dueDate ? b.dueDate.slice(0, 10) : "9999-12-31";
        if (dueA !== dueB) return dueA.localeCompare(dueB);
        if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        }
        return a.title.localeCompare(b.title, "es", { sensitivity: "base" });
      });
  }, [tasks, showCompletedTasks, taskProjectFilter, taskPriorityFilter, taskSearch, focusOnly, focusTodayIds]);

  const aiSnapshot = useMemo(
    () =>
      buildAiEngineSnapshot({
        tasks,
        goals,
        reviews,
        lang: cfg.lang,
        capacityMinutes: cfg.dailyCapacityMin,
        minimumSlots: cfg.dailyMinSlots,
      }),
    [tasks, goals, reviews, cfg.lang, cfg.dailyCapacityMin, cfg.dailyMinSlots],
  );

  const weeklyScores = useMemo(() => {
    const now = new Date(todayISO());
    const days = [...Array(21)].map((_,i) => {
      const d = new Date(now);
      d.setDate(now.getDate() - (20 - i));
      const key = d.toISOString().slice(0,10);
      const r = reviews.find(rv => rv.date.slice(0,10) === key);
      return { date: format(d, 'dd MMM'), score: r?.score ?? 0 };
    });
    return days;
  }, [reviews]);

  const velocityByProject = useMemo(() => {
    const cutoff = new Date(todayISO());
    cutoff.setDate(cutoff.getDate() - 14);
    const proj: Record<string, { points: number; days: Set<string> }> = {};
    reviews
      .filter(r => new Date(r.date) >= cutoff)
      .forEach(r => {
        const day = r.date.slice(0,10);
        r.completedTasks.forEach(id => {
          const t = tasks.find(x => x.id === id);
          if (!t) return;
          if (!proj[t.project]) proj[t.project] = { points: 0, days: new Set() };
          proj[t.project].points += t.points;
          proj[t.project].days.add(day);
        });
      });
    return Object.entries(proj).map(([project, v]) => ({ project, velocity: v.days.size ? v.points / v.days.size : 0 }));
  }, [reviews, tasks]);

  // ====== Acciones ======
  function addGoal(g: Omit<Goal, "id" | "createdAt" | "history">) {
    registerProject(g.project);
    setGoals(prev => [...prev, { id: uuidv4(), createdAt: todayISO(), history: [], ...g }]);
  }

  function logGoalProgress(goalId: string, units: number) {
    setGoals(prev => prev.map(g => g.id === goalId ? { ...g, history: [...g.history, { date: todayISO(), units }] } : g));
  }

  function addTask(t: Omit<Task, "id" | "createdAt" | "done">) {
    registerProject(t.project);
    setTasks(prev => [{ id: uuidv4(), createdAt: todayISO(), done: false, priority: "med", ...t }, ...prev]);
  }

  function toggleTask(id: string) {
    setTasks(prev => prev.map(t => t.id === id ? { ...t, done: !t.done } : t));
  }

  function updateTask(id: string, patch: Partial<Task>) {
    setTasks(prev => prev.map(task => (task.id === id ? { ...task, ...patch } : task)));
  }

  function removeTask(id: string) {
    setTasks(prev => prev.filter(t => t.id !== id));
    setAiFocus(prev =>
      prev.date === todayKey ? { ...prev, taskIds: prev.taskIds.filter(taskId => taskId !== id) } : prev,
    );
    setEditingTask(prev => (prev && prev.id === id ? null : prev));
  }

  const applyAiPlan = useCallback((snapshot: AiEngineSnapshot) => {
    if (!snapshot.plan.length) return;
    const todayIso = todayISO();
    const existingSelections = snapshot.plan.filter(item => item.kind === "existing" && item.existingTaskId);
    const map = new Map(existingSelections.map(item => [item.existingTaskId!, item]));
    const suggestions = snapshot.plan.filter(item => item.kind === "suggested");
    suggestions.forEach(item => registerProject(item.project));
    const newTasks = suggestions.map(item => ({
      id: uuidv4(),
      title: item.title,
      project: item.project,
      estimateMin: item.estimateMin,
      points: Math.max(10, Math.round(item.estimateMin / 15) * 5),
      done: false,
      createdAt: todayIso,
      dueDate: todayIso,
      priority: "med" as const,
      notes: item.reason,
    }));

    const focusIds: string[] = [];
    setTasks(prev => {
      const updated = prev.map(task => {
        const selected = map.get(task.id);
        if (!selected) return task;
        focusIds.push(task.id);
        const currentDue = task.dueDate && task.dueDate.slice(0, 10) <= todayIso.slice(0, 10) ? task.dueDate : todayIso;
        const reasonTag = selected.reason;
        const alreadyTagged = reasonTag && task.notes?.includes(reasonTag);
        return {
          ...task,
          dueDate: currentDue,
          priority: "high",
          notes: reasonTag && !alreadyTagged ? [task.notes, `IA: ${reasonTag}`].filter(Boolean).join("\n") : task.notes,
        };
      });
      if (newTasks.length === 0) return updated;
      newTasks.forEach(t => focusIds.push(t.id));
      return [...newTasks, ...updated];
    });

    setAiFocus({ date: todayIso.slice(0, 10), taskIds: focusIds, summary: snapshot.summary });
  }, [registerProject]);

  function closeDay(notes?: string) {
    const today = todayISO().slice(0,10);
    const completed = tasks.filter(t => t.done && t.createdAt.slice(0,10) === today);
    const taskPoints = completed.reduce((acc, t) => acc + (t.points + (t.priority === 'high' ? 10 : 0)), 0);
    const progressed = goals.some(g => g.history.some(h => h.date.slice(0,10) === today));
    const raw = taskPoints + (progressed ? 10 : 0);
    const score = Math.max(0, Math.min(100, Math.round(raw)));
    const review: DailyReview = { id: uuidv4(), date: todayISO(), score, completedTasks: completed.map(t => t.id), notes };
    setReviews(prev => {
      const other = prev.filter(r => r.date.slice(0,10) !== today);
      return [...other, review];
    });
  }

  function etaForGoal(g: Goal) {
    const cutoff = new Date(todayISO());
    cutoff.setDate(cutoff.getDate() - 14);
    const recent = g.history.filter(h => new Date(h.date) >= cutoff);
    const total = recent.reduce((a,b) => a + b.units, 0);
    const days = new Set(recent.map(h => h.date.slice(0,10))).size || 1;
    const rate = total / days; // unidades por día
    const done = g.history.reduce((a,b) => a + b.units, 0);
    const remaining = Math.max(0, g.targetUnits - done);
    if (rate <= 0) return "—";
    const daysNeeded = Math.ceil(remaining / rate);
    const targetDate = new Date();
    targetDate.setDate(targetDate.getDate() + daysNeeded);
    return `${daysNeeded} días · ${format(targetDate, 'dd/MM/yyyy')}`;
  }

  function updateGoal(id: string, patch: Partial<Goal>) {
    setGoals(prev => prev.map(goal => (goal.id === id ? { ...goal, ...patch } : goal)));
  }

  function removeGoal(id: string) {
    setGoals(prev => prev.filter(goal => goal.id !== id));
    setEditingGoal(prev => (prev && prev.id === id ? null : prev));
  }

  function removeGoalProgress(goalId: string, entryIndex: number) {
    setGoals(prev =>
      prev.map(goal =>
        goal.id === goalId
          ? { ...goal, history: goal.history.filter((_, idx) => idx !== entryIndex) }
          : goal,
      ),
    );
  }

  function removeProject(name: string) {
    const normalized = name.trim().toLowerCase();
    if ([defaultProjectName.toLowerCase(), supportProjectName.toLowerCase()].includes(normalized)) {
      window.alert(t.cannotRemoveDefault);
      return;
    }
    const usage =
      tasks.filter(task => task.project === name).length +
      goals.filter(goal => goal.project === name).length;
    const confirmation =
      usage > 0
        ? `${t.removeProject} "${name}" · ${t.confirmRemoveProject.replace("{count}", String(usage))}`
        : `${t.removeProject} "${name}"?`;
    if (!window.confirm(confirmation)) return;
    if (usage > 0) {
      const fallback = supportProjectName || defaultProjectName || name;
      setTasks(prev => prev.map(task => (task.project === name ? { ...task, project: fallback } : task)));
      setGoals(prev => prev.map(goal => (goal.project === name ? { ...goal, project: fallback } : goal)));
    }
    setProjects(prev => prev.filter(project => project !== name));
  }

  const createWorkspacePage = useCallback(
    (template: WorkspaceTemplateKey) => {
      const now = new Date().toISOString();
      const color = WORKSPACE_COLORS[Math.floor(Math.random() * WORKSPACE_COLORS.length)];
      const iconMap: Record<WorkspaceTemplateKey, string> = {
        blank: "📄",
        daily: "🌅",
        project: "🗂️",
        knowledge: "🧠",
      };
      const titleMap: Record<WorkspaceTemplateKey, string> = {
        blank: t.workspaceTemplateBlankTitle,
        daily: t.workspaceTemplateDailyTitle,
        project: t.workspaceTemplateProjectTitle,
        knowledge: t.workspaceTemplateKnowledgeTitle,
      };
      const descMap: Record<WorkspaceTemplateKey, string> = {
        blank: t.workspaceTemplateBlankDescription,
        daily: t.workspaceTemplateDailyDescription,
        project: t.workspaceTemplateProjectDescription,
        knowledge: t.workspaceTemplateKnowledgeDescription,
      };
      const tagMap: Record<WorkspaceTemplateKey, string[]> = {
        blank: ["notes"],
        daily: ["daily", "ritual"],
        project: ["project", "roadmap"],
        knowledge: ["knowledge", "ideas"],
      };
      const buildBlocks = (): WorkspaceBlock[] => {
        switch (template) {
          case "daily":
            return [
              { id: uuidv4(), type: "heading", text: t.workspaceBlockToday, accent: "emerald" },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockDailyFocus, checked: false },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockDailySecondary, checked: false },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockSharpen, checked: false },
              { id: uuidv4(), type: "divider", text: "" },
              { id: uuidv4(), type: "heading", text: t.workspaceBlockHighlights, accent: "sky" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockHighlightsHint },
            ];
          case "project":
            return [
              { id: uuidv4(), type: "heading", text: t.workspaceBlockNorthStar, accent: "violet" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockNorthStarHint },
              { id: uuidv4(), type: "heading", text: t.workspaceBlockRoadmap, accent: "emerald" },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockMilestoneOne, checked: false },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockMilestoneTwo, checked: false },
              { id: uuidv4(), type: "todo", text: t.workspaceBlockMilestoneThree, checked: false },
              { id: uuidv4(), type: "divider", text: "" },
              { id: uuidv4(), type: "heading", text: t.workspaceBlockResources, accent: "sky" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockResourcesHint },
            ];
          case "knowledge":
            return [
              { id: uuidv4(), type: "heading", text: t.workspaceBlockQuestions, accent: "amber" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockQuestionsHint },
              { id: uuidv4(), type: "heading", text: t.workspaceBlockIdeas, accent: "emerald" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockIdeasHint },
              { id: uuidv4(), type: "heading", text: t.workspaceBlockReferences, accent: "sky" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockReferencesHint },
            ];
          default:
            return [
              { id: uuidv4(), type: "heading", text: t.workspaceBlockBlankHeading, accent: "slate" },
              { id: uuidv4(), type: "text", text: t.workspaceBlockBlankHint },
            ];
        }
      };
      const page: WorkspacePage = {
        id: uuidv4(),
        icon: iconMap[template] ?? "📄",
        title: titleMap[template],
        description: descMap[template],
        color,
        createdAt: now,
        updatedAt: now,
        tags: tagMap[template],
        favorite: template !== "blank",
        blocks: buildBlocks(),
      };
      setWorkspacePages(prev => [page, ...prev]);
      setActiveWorkspacePageId(page.id);
    },
    [t],
  );

  const updateWorkspacePage = useCallback((id: string, patch: Partial<WorkspacePage>) => {
    setWorkspacePages(prev =>
      prev.map(page =>
        page.id === id
          ? {
              ...page,
              ...patch,
              blocks: patch.blocks ? patch.blocks : page.blocks,
              updatedAt: new Date().toISOString(),
            }
          : page,
      ),
    );
  }, []);

  const updateWorkspaceBlocks = useCallback(
    (id: string, blocks: WorkspaceBlock[]) => {
      updateWorkspacePage(id, { blocks });
    },
    [updateWorkspacePage],
  );

  const toggleWorkspaceFavorite = useCallback((id: string) => {
    setWorkspacePages(prev =>
      prev.map(page =>
        page.id === id
          ? { ...page, favorite: !page.favorite, updatedAt: new Date().toISOString() }
          : page,
      ),
    );
  }, []);

  const removeWorkspacePage = useCallback(
    (id: string) => {
      setWorkspacePages(prev => {
        const filtered = prev.filter(page => page.id !== id);
        if (!filtered.length) {
          const defaults = createDefaultWorkspacePages();
          setActiveWorkspacePageId(defaults[0]?.id || "");
          return defaults;
        }
        if (id === activeWorkspacePageId || !filtered.some(page => page.id === activeWorkspacePageId)) {
          setActiveWorkspacePageId(filtered[0]?.id || "");
        }
        return filtered;
      });
    },
    [activeWorkspacePageId],
  );

  const duplicateWorkspacePage = useCallback(
    (id: string) => {
      const source = workspacePages.find(page => page.id === id);
      if (!source) return;
      const now = new Date().toISOString();
      const copy: WorkspacePage = {
        ...source,
        id: uuidv4(),
        title: `${source.title} · ${t.workspaceDuplicateSuffix}`,
        favorite: false,
        createdAt: now,
        updatedAt: now,
        blocks: source.blocks.map(block => ({ ...block, id: uuidv4() })),
      };
      setWorkspacePages(prev => [copy, ...prev]);
      setActiveWorkspacePageId(copy.id);
    },
    [workspacePages, t.workspaceDuplicateSuffix],
  );

  const updateGcalConfig = useCallback((patch: Partial<GoogleCalendarConfig>) => {
    setGcalConfig(prev => ({ ...prev, ...patch }));
  }, []);

  const syncGoogleCalendar = useCallback(
    async (interactive: boolean) => {
      if (!gapiReady || typeof window === "undefined" || !(window as any).gapi) {
        setGcalState(prev => ({
          ...prev,
          status: "error",
          message: t.calendarStatusNoApi,
        }));
        return;
      }
      const gapi = (window as any).gapi;
      try {
        setGcalState(prev => ({ ...prev, status: "loading", message: t.calendarConnecting }));
        await new Promise<void>((resolve, reject) => {
          gapi.load("client:auth2", { callback: resolve, onerror: reject });
        });
        await gapi.client.init({
          apiKey: gcalConfig.apiKey,
          clientId: gcalConfig.clientId,
          discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
          scope: "https://www.googleapis.com/auth/calendar.readonly",
        });
        const auth = gapi.auth2.getAuthInstance();
        let user = auth.currentUser.get();
        if (!user || !user.isSignedIn()) {
          if (interactive) {
            user = await auth.signIn();
          } else {
            try {
              user = await auth.signIn({ prompt: "none" });
            } catch {
              user = auth.currentUser.get();
            }
          }
        }
        if (!user || !user.isSignedIn()) {
          if (!interactive) {
            setGcalState(prev => ({
              ...prev,
              status: "error",
              message: t.calendarAuthRequired,
            }));
            return;
          }
          user = await auth.signIn();
        }
        const profile = user?.getBasicProfile ? user.getBasicProfile() : null;
        const horizon = new Date();
        const spanMs = gcalConfig.lookAheadDays * 24 * 60 * 60 * 1000;
        const timeMin = new Date().toISOString();
        const timeMax = new Date(horizon.getTime() + spanMs).toISOString();
        const response = await gapi.client.calendar.events.list({
          calendarId: gcalConfig.calendarId || "primary",
          singleEvents: true,
          orderBy: "startTime",
          timeMin,
          timeMax,
          timeZone: gcalConfig.timeZone,
          maxResults: 64,
        });
        const events = (response.result?.items || []).map((event: any) => ({
          id: event.id,
          summary: event.summary || t.calendarUntitled,
          start: event.start?.dateTime || event.start?.date,
          end: event.end?.dateTime || event.end?.date || event.start?.dateTime || event.start?.date,
          location: event.location,
          hangoutLink: event.hangoutLink || event.conferenceData?.entryPoints?.[0]?.uri,
          description: event.description,
        })) as GoogleCalendarEvent[];
        setGcalState({
          status: "connected",
          message: t.calendarSyncedAt.replace("{time}", format(new Date(), "HH:mm")),
          events,
          profile: profile
            ? {
                name: profile.getName?.(),
                email: profile.getEmail?.(),
                avatar: profile.getImageUrl?.(),
              }
            : undefined,
          lastSyncedAt: new Date().toISOString(),
        });
      } catch (error) {
        console.error(error);
        setGcalState(prev => ({
          ...prev,
          status: "error",
          message:
            error instanceof Error
              ? error.message
              : typeof error === "string"
              ? error
              : t.calendarUnknownError,
        }));
      }
    },
    [gapiReady, gcalConfig, t.calendarConnecting, t.calendarSyncedAt, t.calendarUntitled, t.calendarStatusNoApi, t.calendarAuthRequired, t.calendarUnknownError],
  );

  const connectGoogleCalendar = useCallback(() => {
    return syncGoogleCalendar(true);
  }, [syncGoogleCalendar]);

  const refreshGoogleCalendar = useCallback(() => {
    return syncGoogleCalendar(false);
  }, [syncGoogleCalendar]);

  const disconnectGoogleCalendar = useCallback(async () => {
    if (typeof window !== "undefined" && (window as any).gapi?.auth2) {
      try {
        await (window as any).gapi.auth2.getAuthInstance()?.signOut();
      } catch {}
    }
    setGcalState({ status: "idle", events: [], message: t.calendarDisconnected, profile: undefined, lastSyncedAt: undefined });
  }, [t.calendarDisconnected]);

  // ====== Import/Export ======
  function exportAll() {
    const blob = new Blob([JSON.stringify({ goals, tasks, reviews, cfg }, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'classroom-ia-backup.json'; a.click();
    URL.revokeObjectURL(url);
  }
  function importAll(file: File) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const obj = JSON.parse(String(reader.result));
        if (obj.goals) setGoals(obj.goals);
        if (obj.tasks) setTasks(obj.tasks);
        if (obj.reviews) setReviews(obj.reviews);
        if (obj.cfg) setCfg(obj.cfg);
      } catch {}
    };
    reader.readAsText(file);
  }

  // ====== Atajos de teclado ======
  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.altKey && e.key.toLowerCase() === 'n') {
        const title = prompt('Tarea rápida');
        if (title) addTask({ title, project: defaultProject, estimateMin: 30, points: 20 });
      }
      if (e.altKey && e.key.toLowerCase() === 'd') {
        closeDay('Atajo de teclado');
      }
    }
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [tasks, goals, defaultProject]);

  // ====== Notificaciones ======
  useEffect(() => {
    if (cfg.notifications && 'Notification' in window) {
      if (Notification.permission === 'default') Notification.requestPermission();
    }
  }, [cfg.notifications]);

  // ============== UI ==============
  return (
    <SurfaceContext.Provider value={surfaceTokens}>
      <div
      className={`relative min-h-screen w-full overflow-hidden ${
        cfg.theme === 'dark'
          ? 'bg-neutral-950 text-neutral-100'
          : 'bg-gradient-to-br from-slate-50 via-white to-sky-50 text-neutral-900'
      }`}
    >
      <div className="pointer-events-none absolute inset-0 -z-10">
        <div className="absolute -top-32 -left-32 h-72 w-72 rounded-full bg-emerald-300/30 blur-3xl animate-pulse" />
        <div className="absolute top-1/3 right-[-120px] h-80 w-80 rounded-full bg-sky-300/20 blur-3xl animate-[pulse_8s_ease-in-out_infinite]" />
        <div className="absolute bottom-[-140px] left-1/4 h-96 w-96 rounded-full bg-indigo-300/20 blur-3xl" />
      </div>
      <div className="relative mx-auto max-w-6xl space-y-6 p-4 md:p-8">
        <header className="flex items-center justify-between">
          <h1 className="flex items-center gap-2 text-2xl font-bold tracking-tight md:text-3xl">
            <Rocket className="h-6 w-6 text-emerald-500 dark:text-emerald-300" />
            <span className="bg-gradient-to-r from-emerald-500 via-sky-500 to-indigo-500 bg-clip-text text-transparent dark:from-emerald-300 dark:via-sky-400 dark:to-indigo-400">
              {t.title}
            </span>
          </h1>
          <div className="flex items-center gap-3 text-sm">
            <span>{t.today}: {format(new Date(), 'dd/MM/yyyy')}</span>
            <ThemeToggle cfg={cfg} setCfg={setCfg} t={t} />
          </div>
        </header>

        {/* Top: KPIs y gráfica */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <SurfaceCard className="md:col-span-3">
            <CardHeader className="pb-2">
              <CardTitle>{t.dailyScore}</CardTitle>
            </CardHeader>
            <CardContent className="h-56">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={weeklyScores}>
                  <defs>
                    <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="5%" stopOpacity={0.35} />
                      <stop offset="95%" stopOpacity={0} />
                    </linearGradient>
                  </defs>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" />
                  <YAxis domain={[0,100]} />
                  <Tooltip />
                  <Area type="monotone" dataKey="score" strokeWidth={2} fillOpacity={1} fill="url(#g)" />
                </AreaChart>
              </ResponsiveContainer>
            </CardContent>
          </SurfaceCard>
          <SurfaceCard>
            <CardHeader className="pb-2">
              <CardTitle>{t.velocity}</CardTitle>
            </CardHeader>
            <CardContent className="h-56">
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={velocityByProject}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="project" />
                  <YAxis />
                  <Tooltip />
                  <Bar dataKey="velocity" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </SurfaceCard>
        </div>

        <Tabs defaultValue="tasks" className="w-full">
        <TabsList className="flex flex-wrap gap-2">
          <TabsTrigger value="tasks">{t.tasks}</TabsTrigger>
          <TabsTrigger value="goals">{t.goals}</TabsTrigger>
          <TabsTrigger value="week">{t.week}</TabsTrigger>
          <TabsTrigger value="workspace" className="flex items-center gap-1">
            <LayoutDashboard className="h-4 w-4" /> {t.workspace}
          </TabsTrigger>
          <TabsTrigger value="coach">{t.aiCoach}</TabsTrigger>
          <TabsTrigger value="chatbot" className="flex items-center gap-1">
            <Sparkles className="h-4 w-4" /> {t.chatbot}
          </TabsTrigger>
          <TabsTrigger value="calendar" className="flex items-center gap-1">
            <CalendarDays className="h-4 w-4" /> {t.calendar}
          </TabsTrigger>
          <TabsTrigger value="backlog">{t.backlog}</TabsTrigger>
          <TabsTrigger value="focus">{t.focus}</TabsTrigger>
          <TabsTrigger value="templates">{t.templates}</TabsTrigger>
          <TabsTrigger value="review">{t.review}</TabsTrigger>
          <TabsTrigger value="settings"><Settings className="h-4 w-4" /></TabsTrigger>
        </TabsList>

          {/* ====== TAREAS ====== */}
          <TabsContent value="tasks" className="mt-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <SurfaceCard className="md:col-span-2">
                <CardHeader className="pb-2"><CardTitle>{t.pending}</CardTitle></CardHeader>
                <CardContent className="space-y-4">
                  <TaskFilters
                    t={t}
                    projects={effectiveProjects}
                    projectValue={taskProjectFilter}
                    onProjectChange={setTaskProjectFilter}
                    priorityValue={taskPriorityFilter}
                    onPriorityChange={setTaskPriorityFilter}
                    searchValue={taskSearch}
                    onSearchChange={setTaskSearch}
                    showCompleted={showCompletedTasks}
                    onToggleCompleted={setShowCompletedTasks}
                    focusOnly={focusOnly}
                    onToggleFocus={setFocusOnly}
                    onReset={() => {
                      setTaskProjectFilter("all");
                      setTaskPriorityFilter("all");
                      setTaskSearch("");
                      setShowCompletedTasks(false);
                      setFocusOnly(false);
                    }}
                  />
                  <div className="flex flex-col gap-3 lg:flex-row lg:items-center lg:justify-between">
                    <QuickAdd onAdd={(title) => addTask({ title, project: defaultProject, estimateMin: 30, points: 20 })} label={t.quickAdd} />
                    <div className="flex flex-wrap gap-2">
                      <BulkTaskDialog
                        t={t}
                        projects={effectiveProjects}
                        onAddProject={registerProject}
                        onSubmit={(items) => {
                          items.forEach(item => addTask(item));
                        }}
                        fallbackProject={defaultProject}
                      />
                    </div>
                  </div>
                  <div className="space-y-3">
                    {visibleTasks.length === 0 && (
                      <div className="text-sm text-neutral-500">{t.emptyTasks}</div>
                    )}
                    {visibleTasks.map(task => (
                      <TaskRow
                        key={task.id}
                        task={task}
                        toggle={toggleTask}
                        focus={focusTodayIds.has(task.id)}
                        focusLabel={t.aiFocusBadge}
                        onEdit={() => setEditingTask(task)}
                        onDelete={() => {
                          if (window.confirm(t.confirmDeleteTask)) {
                            removeTask(task.id);
                          }
                        }}
                        t={t}
                      />
                    ))}
                  </div>
                </CardContent>
              </SurfaceCard>

              <SurfaceCard>
                <CardHeader className="pb-2"><CardTitle>{t.newTask}</CardTitle></CardHeader>
                <TaskForm onCreate={addTask} t={t} projects={effectiveProjects} onAddProject={registerProject} fallbackProject={defaultProject} />
              </SurfaceCard>
            </div>
          </TabsContent>

          {/* ====== METAS ====== */}
          <TabsContent value="goals" className="mt-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <SurfaceCard className="md:col-span-2">
                <CardHeader className="pb-2"><CardTitle>{t.activeGoals}</CardTitle></CardHeader>
                <CardContent className="space-y-3">
                  {goals.length === 0 && <div className="text-sm text-neutral-500">Sin metas no hay milagros.</div>}
                  {goals.map(g => {
                    const totalUnits = g.history.reduce((acc, entry) => acc + entry.units, 0);
                    const completion = g.targetUnits ? Math.min(100, (totalUnits / g.targetUnits) * 100) : 0;
                    return (
                      <div key={g.id} className="relative overflow-hidden rounded-2xl border border-neutral-200 bg-white/90 p-3 shadow-sm transition-all duration-200 dark:border-neutral-700 dark:bg-neutral-900/70">
                        <div className="absolute inset-0 -z-10 bg-gradient-to-br from-emerald-200/30 via-transparent to-sky-200/30 dark:from-emerald-500/10 dark:to-sky-500/10" />
                        <div className="space-y-3">
                          <div className="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
                            <div>
                              <div className="text-lg font-semibold leading-tight">{g.title}</div>
                              <div className="text-xs text-neutral-500 dark:text-neutral-400">{g.project} · {t.goalProgress}: {totalUnits} / {g.targetUnits} {g.unitLabel}{g.dueDate ? ` · ${t.due} ${format(new Date(g.dueDate), 'dd/MM')}` : ''}</div>
                            </div>
                            <div className="flex items-center gap-2">
                              <Badge variant="secondary">{t.eta}: {etaForGoal(g)}</Badge>
                              <div className="flex items-center gap-1">
                                <Button variant="ghost" size="icon" onClick={() => setEditingGoal(g)} aria-label={`${t.edit} ${g.title}`}><Pencil className="h-4 w-4" /></Button>
                                <Button
                                  variant="ghost"
                                  size="icon"
                                  onClick={() => {
                                    if (window.confirm(t.confirmDeleteGoal)) {
                                      removeGoal(g.id);
                                    }
                                  }}
                                  aria-label={`${t.delete} ${g.title}`}
                                >
                                  <Trash2 className="h-4 w-4" />
                                </Button>
                              </div>
                            </div>
                          </div>
                          <div>
                            <div className="flex items-center justify-between text-xs font-medium text-neutral-600 dark:text-neutral-300">
                              <span>{Math.round(completion)}%</span>
                              <span>{totalUnits} / {g.targetUnits} {g.unitLabel}</span>
                            </div>
                            <div className="mt-1 h-2 w-full overflow-hidden rounded-full bg-neutral-200 dark:bg-neutral-800">
                              <div
                                className="h-full rounded-full bg-gradient-to-r from-emerald-400 via-emerald-500 to-sky-500 transition-all"
                                style={{ width: `${Math.min(100, completion)}%` }}
                              />
                            </div>
                          </div>
                          <GoalMiniChart goal={g} t={t} />
                          <div className="space-y-2">
                            <div className="text-xs font-semibold uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.historyEntries}</div>
                            <GoalHistoryList goal={g} t={t} onRemove={(index) => removeGoalProgress(g.id, index)} />
                          </div>
                          <div className="flex flex-col gap-2 sm:flex-row sm:items-end">
                            <div className="grow">
                              <Label className="text-xs">Registrar avance de hoy ({g.unitLabel})</Label>
                              <Input type="number" min={0} step={1} placeholder={`ej. 3`} onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  const v = Number((e.target as HTMLInputElement).value);
                                  if (!isNaN(v) && v >= 0) {
                                    logGoalProgress(g.id, v);
                                    (e.target as HTMLInputElement).value = '';
                                  }
                                }
                              }} />
                            </div>
                            <Button onClick={() => logGoalProgress(g.id, 1)}>+1</Button>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </CardContent>
              </SurfaceCard>

              <SurfaceCard>
                <CardHeader className="pb-2"><CardTitle>{t.newGoal}</CardTitle></CardHeader>
                <GoalForm onCreate={addGoal} t={t} projects={effectiveProjects} onAddProject={registerProject} fallbackProject={defaultProject} />
              </SurfaceCard>
            </div>
          </TabsContent>

          {/* ====== SEMANA ====== */}
          <TabsContent value="week" className="mt-4">
            <WeekPlan tasks={tasks} addTask={addTask} t={t} defaultProject={defaultProject} />
          </TabsContent>

          {/* ====== WORKSPACE ====== */}
          <TabsContent value="workspace" className="mt-4">
            <WorkspaceStudio
              pages={workspacePages}
              activePage={activeWorkspacePage}
              activePageId={activeWorkspacePageId}
              onSelectPage={setActiveWorkspacePageId}
              onCreatePage={createWorkspacePage}
              onUpdatePage={updateWorkspacePage}
              onUpdateBlocks={updateWorkspaceBlocks}
              onRemovePage={removeWorkspacePage}
              onDuplicatePage={duplicateWorkspacePage}
              onToggleFavorite={toggleWorkspaceFavorite}
              t={t}
            />
          </TabsContent>

          {/* ====== CALENDARIO ====== */}
          <TabsContent value="calendar" className="mt-4">
            <CalendarPane
              config={gcalConfig}
              state={gcalState}
              ready={gapiReady}
              onConfigChange={updateGcalConfig}
              onConnect={connectGoogleCalendar}
              onRefresh={refreshGoogleCalendar}
              onDisconnect={disconnectGoogleCalendar}
              t={t}
            />
          </TabsContent>

          {/* ====== MOTOR IA ====== */}
          <TabsContent value="coach" className="mt-4">
            <AIPlanner snapshot={aiSnapshot} onApply={() => applyAiPlan(aiSnapshot)} focusState={aiFocus} t={t} />
          </TabsContent>

          {/* ====== CHATBOT ====== */}
          <TabsContent value="chatbot" className="mt-4">
            <ProjectChatbot
              tasks={tasks}
              goals={goals}
              aiFocus={aiFocus}
              projects={effectiveProjects}
              t={t}
              lang={cfg.lang}
            />
          </TabsContent>

          {/* ====== BACKLOG ====== */}
          <TabsContent value="backlog" className="mt-4">
            <Backlog tasks={tasks} setTasks={setTasks} t={t} />
          </TabsContent>

          {/* ====== FOCO ====== */}
          <TabsContent value="focus" className="mt-4">
            <FocusTimer cfg={cfg} setCfg={setCfg} t={t} />
          </TabsContent>

          {/* ====== PLANTILLAS ====== */}
          <TabsContent value="templates" className="mt-4">
            <Templates
              addTask={addTask}
              addGoal={addGoal}
              projects={effectiveProjects}
              onAddProject={registerProject}
              t={t}
              defaultProject={defaultProject}
              lang={cfg.lang}
              supportProject={supportProjectName}
            />
          </TabsContent>

          {/* ====== CIERRE DEL DÍA ====== */}
          <TabsContent value="review" className="mt-4">
            <SurfaceCard>
              <CardHeader className="pb-2"><CardTitle>{t.closeChecklist}</CardTitle></CardHeader>
              <CardContent className="space-y-4">
                <div className="text-sm">{t.closeHint}</div>
                <Dialog>
                  <DialogTrigger asChild>
                    <Button size="lg">{t.grade}</Button>
                  </DialogTrigger>
                  <DialogContent className={cx("max-w-2xl", surfaceTokens.dialog)} style={surfaceTokens.dialogStyle}>
                    <DialogHeader>
                      <DialogTitle>{t.review}</DialogTitle>
                    </DialogHeader>
                    <ReviewForm onSubmit={(notes) => closeDay(notes)} t={t} />
                  </DialogContent>
                </Dialog>

                <div className="pt-2">
                  <div className="font-semibold mb-2">{t.history}</div>
                  <div className="grid grid-cols-2 md:grid-cols-6 gap-2">
                    {reviews.sort((a,b) => a.date.localeCompare(b.date)).map(r => (
                      <div key={r.id} className="rounded-xl border p-2 text-center">
                        <div className="text-xs text-neutral-500">{format(new Date(r.date), 'dd/MM')}</div>
                        <div className="text-lg font-bold">{r.score}</div>
                      </div>
                    ))}
                  </div>
                </div>
              </CardContent>
            </SurfaceCard>
          </TabsContent>

          {/* ====== AJUSTES ====== */}
          <TabsContent value="settings" className="mt-4">
            <SettingsPane
              cfg={cfg}
              setCfg={setCfg}
              exportAll={exportAll}
              importAll={importAll}
              t={t}
              projects={projects}
              onRemoveProject={removeProject}
              uiPrefs={uiPrefs}
              setUiPrefs={setUiPrefs}
              defaultProjectName={defaultProjectName}
              supportProjectName={supportProjectName}
            />
          </TabsContent>
        </Tabs>

        {/* Footer */}
        <div className="text-center text-xs text-neutral-500 pt-4">Hecho para ejecutar, no para procrastinar.</div>

        <TaskEditDialog
          task={editingTask}
          open={!!editingTask}
          onClose={() => setEditingTask(null)}
          onSubmit={updateTask}
          projects={effectiveProjects}
          fallbackProject={defaultProject}
          onAddProject={registerProject}
          t={t}
        />
        <GoalEditDialog
          goal={editingGoal}
          open={!!editingGoal}
          onClose={() => setEditingGoal(null)}
          onSubmit={updateGoal}
          projects={effectiveProjects}
          fallbackProject={defaultProject}
          onAddProject={registerProject}
          t={t}
        />
      </div>
      </div>
    </SurfaceContext.Provider>
  );
}

// ============== Subcomponentes ==============
function WorkspaceStudio({
  pages,
  activePage,
  activePageId,
  onSelectPage,
  onCreatePage,
  onUpdatePage,
  onUpdateBlocks,
  onRemovePage,
  onDuplicatePage,
  onToggleFavorite,
  t,
}: {
  pages: WorkspacePage[];
  activePage: WorkspacePage | null;
  activePageId: string | null;
  onSelectPage: (id: string) => void;
  onCreatePage: (template: WorkspaceTemplateKey) => void;
  onUpdatePage: (id: string, patch: Partial<WorkspacePage>) => void;
  onUpdateBlocks: (id: string, blocks: WorkspaceBlock[]) => void;
  onRemovePage: (id: string) => void;
  onDuplicatePage: (id: string) => void;
  onToggleFavorite: (id: string) => void;
  t: any;
}) {
  const [search, setSearch] = useState("");
  const [tagFilter, setTagFilter] = useState<string>("all");

  const templateOptions = useMemo(
    () => [
      { key: "daily" as WorkspaceTemplateKey, label: t.workspaceTemplateDailyName },
      { key: "project" as WorkspaceTemplateKey, label: t.workspaceTemplateProjectName },
      { key: "knowledge" as WorkspaceTemplateKey, label: t.workspaceTemplateKnowledgeName },
      { key: "blank" as WorkspaceTemplateKey, label: t.workspaceNewPage },
    ],
    [t.workspaceTemplateDailyName, t.workspaceTemplateProjectName, t.workspaceTemplateKnowledgeName, t.workspaceNewPage],
  );

  const tags = useMemo(() => {
    const set = new Set<string>();
    pages.forEach(page => page.tags.forEach(tag => set.add(tag)));
    return Array.from(set).sort((a, b) => a.localeCompare(b, "es", { sensitivity: "base" }));
  }, [pages]);

  const filteredPages = useMemo(() => {
    const normalized = search.trim().toLowerCase();
    const tag = tagFilter.toLowerCase();
    return pages
      .filter(page => (tagFilter === "all" ? true : page.tags.some(tg => tg.toLowerCase() === tag)))
      .filter(page =>
        normalized
          ? `${page.title} ${page.description ?? ""} ${page.tags.join(" ")}`
              .toLowerCase()
              .includes(normalized)
          : true,
      )
      .sort((a, b) => {
        if (a.favorite !== b.favorite) return a.favorite ? -1 : 1;
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
      });
  }, [pages, search, tagFilter]);

  const renderPageButton = (page: WorkspacePage) => {
    const styles = WORKSPACE_COLOR_STYLES[page.color] ?? WORKSPACE_COLOR_STYLES.default;
    const isActive = activePageId === page.id;
    return (
      <button
        key={page.id}
        onClick={() => onSelectPage(page.id)}
        className={`group relative w-full rounded-2xl border border-neutral-200/70 bg-gradient-to-br ${
          styles.bg
        } p-3 text-left transition-all hover:-translate-y-[2px] hover:shadow-lg dark:border-neutral-800/70 ${
          isActive ? `${styles.ring} ring-2` : ""
        }`}
      >
        <div className="flex items-start justify-between gap-3">
          <div className={`flex items-center gap-2 text-sm font-semibold ${styles.text}`}>
            <span className="text-base">{page.icon}</span>
            <span className="line-clamp-1">{page.title}</span>
          </div>
          <div className="flex items-center gap-2 text-xs text-neutral-500 dark:text-neutral-400">
            {page.favorite && (
              <Badge variant="secondary" className="bg-amber-500/20 text-amber-600 dark:text-amber-200">
                <Star className="mr-1 h-3 w-3 fill-current" />
                {t.workspaceFavorite}
              </Badge>
            )}
            <span>
              {t.workspaceLastEdited}: {format(new Date(page.updatedAt), "dd MMM HH:mm")}
            </span>
          </div>
        </div>
        {page.tags.length > 0 && (
          <div className="mt-2 flex flex-wrap gap-1 text-[11px]">
            {page.tags.map(tag => (
              <span key={tag} className={`rounded-full px-2 py-0.5 ${styles.pill}`}>
                #{tag}
              </span>
            ))}
          </div>
        )}
        {page.description && (
          <div className="mt-2 text-xs text-neutral-600 dark:text-neutral-300 line-clamp-2">
            {page.description}
          </div>
        )}
      </button>
    );
  };

  return (
    <div className="grid gap-4 lg:grid-cols-[280px,1fr]">
      <SurfaceCard className="h-full">
        <CardHeader className="space-y-2">
          <CardTitle className="flex items-center gap-2 text-base">
            <BookOpen className="h-4 w-4" /> {t.workspacePages}
          </CardTitle>
          <p className="text-xs text-neutral-500 dark:text-neutral-400">{t.workspaceSidebarHint}</p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex flex-wrap gap-2">
            {templateOptions.map(option => (
              <Button
                key={option.key}
                size="sm"
                variant="secondary"
                onClick={() => onCreatePage(option.key)}
                className="flex items-center gap-1 rounded-full bg-white/80 shadow-sm transition hover:-translate-y-[1px] dark:bg-neutral-900/70"
              >
                <Plus className="h-3.5 w-3.5" /> {option.label}
              </Button>
            ))}
          </div>

          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
              {t.workspaceSearchPlaceholder}
            </Label>
            <Input value={search} onChange={e => setSearch(e.target.value)} placeholder={t.workspaceSearchPlaceholder} />
          </div>

          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
              {t.workspaceTagsLabel}
            </Label>
            <div className="flex flex-wrap gap-2">
              <Button
                size="sm"
                variant={tagFilter === "all" ? "default" : "ghost"}
                onClick={() => setTagFilter("all")}
                className="rounded-full"
              >
                {t.workspaceFilterAll}
              </Button>
              {tags.map(tag => (
                <Button
                  key={tag}
                  size="sm"
                  variant={tagFilter === tag ? "default" : "ghost"}
                  onClick={() => setTagFilter(tag)}
                  className="rounded-full"
                >
                  #{tag}
                </Button>
              ))}
            </div>
          </div>

          <div className="max-h-[420px] space-y-2 overflow-y-auto pr-1">
            {filteredPages.length === 0 ? (
              <div className="rounded-2xl border border-dashed p-4 text-sm text-neutral-500 dark:text-neutral-400">
                {pages.length === 0 ? t.workspaceCreateFirst : t.workspaceEmpty}
              </div>
            ) : (
              filteredPages.map(renderPageButton)
            )}
          </div>
        </CardContent>
      </SurfaceCard>

      <div className="space-y-4">
        {activePage ? (
          <WorkspacePageView
            page={activePage}
            onUpdatePage={onUpdatePage}
            onUpdateBlocks={onUpdateBlocks}
            onRemovePage={onRemovePage}
            onDuplicatePage={onDuplicatePage}
            onToggleFavorite={onToggleFavorite}
            t={t}
          />
        ) : (
          <SurfaceCard className="h-full">
            <CardContent className="flex h-full flex-col items-center justify-center gap-3 text-center">
              <Sparkles className="h-10 w-10 text-emerald-400" />
              <div className="text-lg font-semibold">{t.workspace}</div>
              <p className="max-w-sm text-sm text-neutral-500 dark:text-neutral-400">{t.workspaceCreateFirst}</p>
            </CardContent>
          </SurfaceCard>
        )}
      </div>
    </div>
  );
}

function WorkspacePageView({
  page,
  onUpdatePage,
  onUpdateBlocks,
  onRemovePage,
  onDuplicatePage,
  onToggleFavorite,
  t,
}: {
  page: WorkspacePage;
  onUpdatePage: (id: string, patch: Partial<WorkspacePage>) => void;
  onUpdateBlocks: (id: string, blocks: WorkspaceBlock[]) => void;
  onRemovePage: (id: string) => void;
  onDuplicatePage: (id: string) => void;
  onToggleFavorite: (id: string) => void;
  t: any;
}) {
  const [title, setTitle] = useState(page.title);
  const [description, setDescription] = useState(page.description ?? "");
  const [icon, setIcon] = useState(page.icon);
  const [tagsText, setTagsText] = useState(page.tags.join(", "));

  useEffect(() => {
    setTitle(page.title);
    setDescription(page.description ?? "");
    setIcon(page.icon);
    setTagsText(page.tags.join(", "));
  }, [page.id, page.title, page.description, page.icon, page.tags]);

  const styles = WORKSPACE_COLOR_STYLES[page.color] ?? WORKSPACE_COLOR_STYLES.default;
  const quickIcons = ["🚀", "🎯", "🧠", "📚", "💡", "📝", "🗂️", "🌿", "💻"];

  const handleTagsBlur = () => {
    const tags = tagsText
      .split(",")
      .map(tag => tag.trim())
      .filter(Boolean);
    onUpdatePage(page.id, { tags });
  };

  const gradientByColor: Record<string, string> = {
    emerald: "linear-gradient(135deg, rgba(16,185,129,0.7) 0%, rgba(56,189,248,0.35) 100%)",
    sky: "linear-gradient(135deg, rgba(56,189,248,0.7) 0%, rgba(14,165,233,0.35) 100%)",
    violet: "linear-gradient(135deg, rgba(139,92,246,0.7) 0%, rgba(59,130,246,0.35) 100%)",
    amber: "linear-gradient(135deg, rgba(245,158,11,0.75) 0%, rgba(251,191,36,0.45) 100%)",
    rose: "linear-gradient(135deg, rgba(244,114,182,0.7) 0%, rgba(244,63,94,0.35) 100%)",
    slate: "linear-gradient(135deg, rgba(148,163,184,0.7) 0%, rgba(100,116,139,0.35) 100%)",
  };

  const handleAddBlock = (type: WorkspaceBlock["type"]) => {
    const defaultTextMap: Record<WorkspaceBlock["type"], string> = {
      heading: t.workspaceBlockNewHeading,
      todo: t.workspaceBlockNewTodo,
      text: t.workspaceBlockNewText,
      divider: "",
    };
    const block: WorkspaceBlock = {
      id: uuidv4(),
      type,
      text: defaultTextMap[type] ?? "",
      checked: false,
      accent: page.color,
    };
    onUpdateBlocks(page.id, [...page.blocks, block]);
  };

  const handleBlockChange = (blockId: string, patch: Partial<WorkspaceBlock>) => {
    onUpdateBlocks(
      page.id,
      page.blocks.map(block => (block.id === blockId ? { ...block, ...patch } : block)),
    );
  };

  const handleBlockMove = (blockId: string, direction: -1 | 1) => {
    const index = page.blocks.findIndex(block => block.id === blockId);
    if (index < 0) return;
    const target = index + direction;
    if (target < 0 || target >= page.blocks.length) return;
    const next = [...page.blocks];
    const [item] = next.splice(index, 1);
    next.splice(target, 0, item);
    onUpdateBlocks(page.id, next);
  };

  const handleBlockRemove = (blockId: string) => {
    onUpdateBlocks(page.id, page.blocks.filter(block => block.id !== blockId));
  };

  const handleCycleAccent = (blockId: string) => {
    const index = page.blocks.findIndex(block => block.id === blockId);
    if (index < 0) return;
    const current = page.blocks[index];
    const paletteIndex = WORKSPACE_COLORS.findIndex(color => color === current.accent);
    const nextColor = WORKSPACE_COLORS[(paletteIndex + 1) % WORKSPACE_COLORS.length];
    handleBlockChange(blockId, { accent: nextColor });
  };

  return (
    <SurfaceCard className="overflow-hidden">
      <div className={`h-28 bg-gradient-to-r ${styles.bg}`} />
      <CardContent className="-mt-16 space-y-6 rounded-t-3xl border border-neutral-200/70 bg-white/90 p-6 shadow-xl backdrop-blur-sm dark:border-neutral-800/60 dark:bg-neutral-950/80">
        <div className="flex flex-col gap-4 md:flex-row md:items-start md:justify-between">
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <Input
                value={icon}
                onChange={e => setIcon(e.target.value)}
                onBlur={() => onUpdatePage(page.id, { icon: icon || "📄" })}
                className="h-12 w-16 text-2xl"
                aria-label={t.workspaceIconLabel}
              />
              <div className="space-y-2">
                <Input
                  value={title}
                  onChange={e => setTitle(e.target.value)}
                  onBlur={() => onUpdatePage(page.id, { title: title.trim() || t.workspaceTitlePlaceholder })}
                  placeholder={t.workspaceTitlePlaceholder}
                  className="text-lg font-semibold"
                />
                <Textarea
                  value={description}
                  onChange={e => setDescription(e.target.value)}
                  onBlur={() => onUpdatePage(page.id, { description })}
                  placeholder={t.workspaceDescriptionPlaceholder}
                  className="min-h-[80px] resize-y"
                />
              </div>
            </div>
            <div className="flex flex-wrap items-center gap-2 text-xs text-neutral-500 dark:text-neutral-400">
              <span>{t.workspaceColorLabel}</span>
              {WORKSPACE_COLORS.map(color => (
                <button
                  key={color}
                  className={`h-7 w-7 rounded-full border-2 transition ${
                    page.color === color ? "border-emerald-500" : "border-transparent"
                  }`}
                  style={{ background: gradientByColor[color] ?? gradientByColor.emerald }}
                  onClick={() => onUpdatePage(page.id, { color })}
                  aria-label={`${t.workspaceColorLabel} ${color}`}
                />
              ))}
            </div>
            <div className="flex flex-wrap items-center gap-2 text-xs text-neutral-500 dark:text-neutral-400">
              <span>{t.workspaceTagsLabel}</span>
              <Input
                value={tagsText}
                onChange={e => setTagsText(e.target.value)}
                onBlur={handleTagsBlur}
                placeholder={t.workspaceTagsPlaceholder}
                className="max-w-sm"
              />
            </div>
            <div className="flex flex-wrap items-center gap-2">
              {quickIcons.map(item => (
                <Button
                  key={item}
                  size="icon"
                  variant="ghost"
                  onClick={() => {
                    setIcon(item);
                    onUpdatePage(page.id, { icon: item });
                  }}
                  aria-label={`${t.workspaceIconLabel} ${item}`}
                >
                  <span className="text-lg">{item}</span>
                </Button>
              ))}
            </div>
          </div>

          <div className="flex flex-col gap-2 text-sm text-neutral-500 dark:text-neutral-400">
            <div className="flex items-center gap-2">
              <Button
                size="sm"
                variant={page.favorite ? "default" : "ghost"}
                onClick={() => onToggleFavorite(page.id)}
                className="flex items-center gap-1"
                aria-label={t.workspaceFavoriteTooltip}
              >
                <Star className={`h-4 w-4 ${page.favorite ? "fill-current" : ""}`} />
                {t.workspaceFavorite}
              </Button>
              <Button
                size="sm"
                variant="ghost"
                onClick={() => onDuplicatePage(page.id)}
                className="flex items-center gap-1"
              >
                <ListPlus className="h-4 w-4" /> {t.workspaceDuplicate}
              </Button>
              <Button
                size="sm"
                variant="destructive"
                onClick={() => {
                  if (window.confirm(t.workspaceDeleteConfirm)) {
                    onRemovePage(page.id);
                  }
                }}
                className="flex items-center gap-1"
              >
                <Trash2 className="h-4 w-4" /> {t.workspaceDelete}
              </Button>
            </div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">
              {t.workspaceLastEdited}: {format(new Date(page.updatedAt), "dd MMM yyyy · HH:mm")}
            </div>
          </div>
        </div>

        <div className="space-y-3">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <div className="text-sm font-semibold">{t.workspaceAddBlock}</div>
            <div className="flex flex-wrap gap-2">
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock("heading")}> 
                <Sparkles className="mr-1 h-3.5 w-3.5" /> {t.workspaceAddHeading}
              </Button>
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock("todo")}>
                <CheckCircle2 className="mr-1 h-3.5 w-3.5" /> {t.workspaceAddTodo}
              </Button>
              <Button size="sm" variant="secondary" onClick={() => handleAddBlock("text")}>
                <Lightbulb className="mr-1 h-3.5 w-3.5" /> {t.workspaceAddText}
              </Button>
              <Button size="sm" variant="ghost" onClick={() => handleAddBlock("divider")}>
                <Minus className="mr-1 h-3.5 w-3.5" /> {t.workspaceAddDivider}
              </Button>
            </div>
          </div>

          {page.blocks.length === 0 ? (
            <div className="rounded-2xl border border-dashed p-6 text-center text-sm text-neutral-500 dark:text-neutral-400">
              {t.workspaceNoBlocks}
            </div>
          ) : (
            <div className="space-y-3">
              {page.blocks.map((block, index) => (
                <WorkspaceBlockItem
                  key={block.id}
                  block={block}
                  onChange={patch => handleBlockChange(block.id, patch)}
                  onRemove={() => handleBlockRemove(block.id)}
                  onMoveUp={() => handleBlockMove(block.id, -1)}
                  onMoveDown={() => handleBlockMove(block.id, 1)}
                  onToggle={() => handleBlockChange(block.id, { checked: !block.checked })}
                  onCycleAccent={() => handleCycleAccent(block.id)}
                  isFirst={index === 0}
                  isLast={index === page.blocks.length - 1}
                  t={t}
                />
              ))}
            </div>
          )}
        </div>
      </CardContent>
    </SurfaceCard>
  );
}

function WorkspaceBlockItem({
  block,
  onChange,
  onRemove,
  onMoveUp,
  onMoveDown,
  onToggle,
  onCycleAccent,
  isFirst,
  isLast,
  t,
}: {
  block: WorkspaceBlock;
  onChange: (patch: Partial<WorkspaceBlock>) => void;
  onRemove: () => void;
  onMoveUp: () => void;
  onMoveDown: () => void;
  onToggle: () => void;
  onCycleAccent: () => void;
  isFirst: boolean;
  isLast: boolean;
  t: any;
}) {
  const styles = WORKSPACE_COLOR_STYLES[block.accent ?? "default"] ?? WORKSPACE_COLOR_STYLES.default;

  return (
    <div
      className={`relative overflow-hidden rounded-2xl border border-neutral-200/70 bg-white/90 p-4 shadow-sm transition-all hover:-translate-y-[2px] hover:shadow-lg dark:border-neutral-800/70 dark:bg-neutral-900/70`}
    >
      <div className="absolute inset-0 pointer-events-none opacity-70">
        <div className={`absolute inset-0 bg-gradient-to-br ${styles.bg}`} />
      </div>
      <div className="relative space-y-3">
        <div className="flex items-center justify-between gap-2">
          <Badge variant="secondary" className={`${styles.pill} capitalize`}>
            {block.type === "divider" ? t.workspaceDividerLabel : block.type}
          </Badge>
          <div className="flex items-center gap-1 text-neutral-500">
            <Button variant="ghost" size="icon" onClick={onCycleAccent} aria-label={t.workspaceChangeAccent}>
              <Palette className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={onMoveUp} disabled={isFirst} aria-label="Move block up">
              <Upload className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={onMoveDown} disabled={isLast} aria-label="Move block down">
              <Download className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={onRemove} aria-label={t.workspaceDelete}>
              <Trash2 className="h-4 w-4" />
            </Button>
          </div>
        </div>

        {block.type === "heading" && (
          <Input
            value={block.text}
            onChange={e => onChange({ text: e.target.value })}
            className="text-lg font-semibold"
          />
        )}

        {block.type === "text" && (
          <Textarea
            value={block.text}
            onChange={e => onChange({ text: e.target.value })}
            className="min-h-[80px]"
          />
        )}

        {block.type === "todo" && (
          <div className="flex items-start gap-3">
            <Checkbox checked={!!block.checked} onCheckedChange={onToggle} />
            <Input
              value={block.text}
              onChange={e => onChange({ text: e.target.value })}
              className="flex-1"
            />
          </div>
        )}

        {block.type === "divider" && <div className="h-px w-full bg-neutral-300 dark:bg-neutral-700" />}
      </div>
    </div>
  );
}

function CalendarPane({
  config,
  state,
  ready,
  onConfigChange,
  onConnect,
  onRefresh,
  onDisconnect,
  t,
}: {
  config: GoogleCalendarConfig;
  state: GoogleCalendarState;
  ready: boolean;
  onConfigChange: (patch: Partial<GoogleCalendarConfig>) => void;
  onConnect: () => void;
  onRefresh: () => void;
  onDisconnect: () => void;
  t: any;
}) {
  const statusStyles = {
    connected: "bg-emerald-500/20 text-emerald-700 dark:text-emerald-200",
    loading: "bg-sky-500/20 text-sky-700 dark:text-sky-200",
    error: "bg-rose-500/20 text-rose-700 dark:text-rose-200",
    idle: "bg-neutral-500/10 text-neutral-600 dark:text-neutral-300",
  } as const;

  const statusLabel =
    state.status === "connected"
      ? t.calendarStatusConnected
      : state.status === "loading"
      ? t.calendarStatusLoading
      : state.status === "error"
      ? t.calendarStatusError
      : t.calendarStatusIdle;

  const isConnected = state.status === "connected";
  const isLoading = state.status === "loading";

  const handleChange = (field: keyof GoogleCalendarConfig) => (value: string) => {
    if (field === "lookAheadDays") {
      const parsed = Math.max(1, Math.min(31, Number(value) || config.lookAheadDays));
      onConfigChange({ lookAheadDays: parsed });
      return;
    }
    onConfigChange({ [field]: value } as Partial<GoogleCalendarConfig>);
  };

  const renderEvent = (event: GoogleCalendarEvent) => {
    const rawStart = new Date(event.start);
    const rawEnd = event.end ? new Date(event.end) : rawStart;
    const startDate = isNaN(rawStart.getTime()) ? new Date() : rawStart;
    const endDate = isNaN(rawEnd.getTime()) ? startDate : rawEnd;
    const allDay = event.start.length <= 10 || (event.start.length > 10 && event.start.endsWith("00:00:00Z"));
    const dateLabel = allDay
      ? format(startDate, "EEE dd MMM")
      : format(startDate, "EEE dd MMM · HH:mm");
    const timeLabel = allDay
      ? t.calendarEventAllDay
      : `${format(startDate, "HH:mm")} → ${format(endDate, "HH:mm")}`;

    return (
      <div
        key={event.id}
        className="rounded-2xl border border-neutral-200/60 bg-gradient-to-br from-slate-50 via-white to-slate-100 p-4 shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg dark:border-neutral-800/60 dark:from-neutral-900 dark:via-neutral-950 dark:to-neutral-900"
      >
        <div className="flex flex-wrap items-center justify-between gap-2">
          <div>
            <div className="text-sm font-semibold text-neutral-900 dark:text-neutral-100">{event.summary}</div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{dateLabel}</div>
          </div>
          <Badge variant="secondary" className="bg-emerald-500/15 text-emerald-700 dark:text-emerald-200">
            {timeLabel}
          </Badge>
        </div>
        {event.location && (
          <div className="mt-2 text-xs text-neutral-500 dark:text-neutral-400">{event.location}</div>
        )}
        <div className="mt-3 flex flex-wrap items-center gap-2">
          {event.hangoutLink && (
            <a
              href={event.hangoutLink}
              target="_blank"
              rel="noreferrer"
              className="inline-flex items-center gap-1 rounded-full bg-sky-500/10 px-3 py-1 text-xs font-medium text-sky-600 transition hover:bg-sky-500/20 dark:text-sky-300"
            >
              <Link2 className="h-3.5 w-3.5" /> {t.calendarOpenEvent}
            </a>
          )}
          {event.description && (
            <div className="rounded-full bg-neutral-500/10 px-3 py-1 text-xs text-neutral-600 dark:text-neutral-300">
              {event.description.slice(0, 80)}{event.description.length > 80 ? "…" : ""}
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="grid gap-4 xl:grid-cols-[340px,1fr]">
      <SurfaceCard>
        <CardHeader className="space-y-2">
          <CardTitle className="flex items-center gap-2 text-base">
            <CalendarDays className="h-4 w-4" /> {t.calendarHeading}
          </CardTitle>
          <p className="text-xs text-neutral-500 dark:text-neutral-400">{t.calendarIntro}</p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex flex-wrap items-center gap-2 text-xs">
            <Badge className={statusStyles[state.status]}>{statusLabel}</Badge>
            <Badge variant="outline" className="border-sky-400/50 text-sky-600 dark:text-sky-200">
              {ready ? t.calendarReady : t.calendarNotReady}
            </Badge>
            {state.lastSyncedAt && (
              <span className="text-neutral-500 dark:text-neutral-400">
                {t.calendarLastSync}: {format(new Date(state.lastSyncedAt), "dd MMM HH:mm")}
              </span>
            )}
          </div>

          {state.message && (
            <div className="rounded-2xl border border-dashed border-neutral-300/60 bg-white/70 p-3 text-xs text-neutral-600 dark:border-neutral-700 dark:bg-neutral-900/70 dark:text-neutral-300">
              {state.message}
            </div>
          )}

          {state.profile && (
            <div className="flex items-center gap-3 rounded-2xl border border-neutral-200/70 bg-white/80 p-3 text-sm dark:border-neutral-800/70 dark:bg-neutral-900/70">
              <div className="h-9 w-9 overflow-hidden rounded-full bg-neutral-200 dark:bg-neutral-700">
                {state.profile.avatar ? (
                  <img src={state.profile.avatar} alt={state.profile.name ?? "profile"} className="h-full w-full object-cover" />
                ) : (
                  <span className="flex h-full w-full items-center justify-center text-lg">{state.profile.name?.[0] ?? "🌟"}</span>
                )}
              </div>
              <div className="flex flex-col">
                <span className="font-medium">{state.profile.name}</span>
                <span className="text-xs text-neutral-500 dark:text-neutral-400">{t.calendarSignedInAs}: {state.profile.email}</span>
              </div>
            </div>
          )}

          <div className="flex flex-wrap gap-2">
            <Button onClick={onConnect} disabled={!ready || isLoading} className="flex items-center gap-1">
              <Sparkles className="h-4 w-4" /> {t.calendarConnect}
            </Button>
            <Button
              variant="secondary"
              onClick={onRefresh}
              disabled={!isConnected || isLoading}
              className="flex items-center gap-1"
            >
              <RefreshCw className="h-4 w-4" /> {t.calendarRefresh}
            </Button>
            <Button
              variant="ghost"
              onClick={onDisconnect}
              disabled={state.status === "idle" && state.events.length === 0}
              className="flex items-center gap-1 text-rose-500 hover:text-rose-600"
            >
              <XCircle className="h-4 w-4" /> {t.calendarDisconnect}
            </Button>
          </div>

          <div className="grid gap-3 sm:grid-cols-2">
            <div className="space-y-1">
              <Label>{t.calendarApiKey}</Label>
              <Input
                value={config.apiKey}
                onChange={e => handleChange("apiKey")(e.target.value)}
                placeholder="AIza..."
              />
            </div>
            <div className="space-y-1">
              <Label>{t.calendarClientId}</Label>
              <Input
                value={config.clientId}
                onChange={e => handleChange("clientId")(e.target.value)}
                placeholder="xxxx.apps.googleusercontent.com"
              />
            </div>
            <div className="space-y-1">
              <Label>{t.calendarCalendarId}</Label>
              <Input
                value={config.calendarId}
                onChange={e => handleChange("calendarId")(e.target.value)}
                placeholder="primary"
              />
            </div>
            <div className="space-y-1">
              <Label>{t.calendarTimezone}</Label>
              <Input
                value={config.timeZone}
                onChange={e => handleChange("timeZone")(e.target.value)}
                placeholder="America/Mexico_City"
              />
            </div>
            <div className="space-y-1">
              <Label>{t.calendarLookAhead}</Label>
              <Input
                type="number"
                min={1}
                max={31}
                value={config.lookAheadDays}
                onChange={e => handleChange("lookAheadDays")(e.target.value)}
              />
              <p className="text-xs text-neutral-500 dark:text-neutral-400">{t.calendarLookAheadSuffix}</p>
            </div>
          </div>

          <p className="text-xs text-neutral-500 dark:text-neutral-400">
            {t.calendarHint}{" "}
            <a
              href="https://developers.google.com/calendar/api/quickstart/js"
              target="_blank"
              rel="noreferrer"
              className="text-sky-600 underline dark:text-sky-300"
            >
              {t.calendarManualLink}
            </a>
          </p>
        </CardContent>
      </SurfaceCard>

      <SurfaceCard className="min-h-full">
        <CardHeader className="space-y-2">
          <CardTitle className="flex items-center gap-2 text-base">
            <Target className="h-4 w-4" /> {t.calendarUpcoming}
          </CardTitle>
          <p className="text-xs text-neutral-500 dark:text-neutral-400">{t.calendarInstructions}</p>
        </CardHeader>
        <CardContent className="space-y-4">
          {isConnected ? (
            state.events.length === 0 ? (
              <div className="rounded-2xl border border-dashed p-6 text-center text-sm text-neutral-500 dark:text-neutral-400">
                {t.calendarNoEvents}
              </div>
            ) : (
              state.events.map(renderEvent)
            )
          ) : (
            <div className="rounded-2xl border border-dashed p-6 text-center text-sm text-neutral-500 dark:text-neutral-400">
              {ready ? t.calendarStatusReadyHint : t.calendarNotReady}
            </div>
          )}
        </CardContent>
      </SurfaceCard>
    </div>
  );
}

function AIPlanner({ snapshot, onApply, focusState, t }: { snapshot: AiEngineSnapshot; onApply: () => void; focusState: AiFocusState; t: any }) {
  const today = todayISO().slice(0, 10);
  const planEmpty = snapshot.plan.length === 0;
  const isApplied = focusState.date === today && focusState.taskIds.length > 0;

  return (
    <div className="grid grid-cols-1 xl:grid-cols-3 gap-4">
      <SurfaceCard className="xl:col-span-2">
        <CardHeader className="pb-2 space-y-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Sparkles className="h-5 w-5" /> {t.aiSummaryTitle}
          </CardTitle>
          <div className="text-sm leading-relaxed text-neutral-600 dark:text-neutral-300">
            {snapshot.summary}
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex flex-wrap items-center justify-between gap-3 text-xs md:text-sm text-neutral-500">
            <div>
              {t.aiPlanLoad}: {snapshot.stats.planMinutes} min · {t.aiCapacityLabel}: {snapshot.stats.capacityMin} min
            </div>
            <div className="flex items-center gap-2">
              {isApplied && (
                <Badge variant="secondary" className="bg-emerald-500/10 text-emerald-600 dark:text-emerald-300">
                  <CheckCircle2 className="h-3.5 w-3.5" /> {t.aiPlanApplied}
                </Badge>
              )}
              <Button disabled={planEmpty} onClick={onApply} className="flex items-center gap-2">
                <Target className="h-4 w-4" /> {isApplied ? t.aiReapplyPlan : t.aiApplyPlan}
              </Button>
            </div>
          </div>

          {isApplied && (
            <div className="rounded-xl border border-emerald-500/30 bg-emerald-500/10 p-3 text-xs text-emerald-700 dark:text-emerald-300">
              <div className="font-semibold flex items-center gap-2">
                <CheckCircle2 className="h-4 w-4" /> {t.aiPlanAppliedHint}
              </div>
              {focusState.summary && <div className="mt-1 leading-relaxed">{focusState.summary}</div>}
            </div>
          )}

          {planEmpty ? (
            <div className="rounded-xl border border-dashed p-6 text-center text-sm text-neutral-500">
              {t.aiNoPlan}
            </div>
          ) : (
            <div className="space-y-3">
              {snapshot.plan.map(item => {
                const inFocus = item.existingTaskId && isApplied && focusState.taskIds.includes(item.existingTaskId);
                return (
                  <div
                    key={item.id}
                    className={`rounded-2xl border p-3 transition-colors ${
                      item.kind === "suggested"
                        ? "border-amber-400/70 bg-amber-100/60 dark:border-amber-400/40 dark:bg-amber-500/10"
                        : "border-neutral-200 bg-white/80 dark:border-neutral-800 dark:bg-neutral-900/60"
                    }`}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <div className="space-y-1">
                        <div className="flex flex-wrap items-center gap-2 font-semibold">
                          {item.kind === "existing" ? (
                            <Focus className="h-4 w-4" />
                          ) : (
                            <Lightbulb className="h-4 w-4" />
                          )}
                          <span>{item.title}</span>
                          {item.kind === "suggested" && <Badge variant="secondary">{t.aiSuggested}</Badge>}
                          {inFocus && (
                            <Badge variant="outline" className="border-emerald-500 text-emerald-600 dark:text-emerald-300">
                              {t.aiFocusBadge}
                            </Badge>
                          )}
                        </div>
                        <div className="text-xs text-neutral-500">
                          {item.project} · {item.estimateMin} min
                        </div>
                        <div className="text-xs leading-snug text-neutral-600 dark:text-neutral-300">
                          {item.reason}
                        </div>
                      </div>
                      <div className="text-xs font-semibold text-neutral-500">{Math.round(item.score)}</div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </CardContent>
      </SurfaceCard>

      <div className="space-y-4">
        <SurfaceCard>
          <CardHeader className="pb-2">
            <CardTitle className="flex items-center gap-2 text-base">
              <Target className="h-4 w-4" /> {t.aiGoalPulse}
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            {snapshot.commitments.length === 0 ? (
              <div className="text-sm text-neutral-500">{t.aiNoGoals}</div>
            ) : (
              snapshot.commitments.slice(0, 5).map(commitment => (
                <div key={commitment.goalId} className="rounded-xl border p-3 space-y-1">
                  <div className="flex items-center justify-between gap-2">
                    <div className="font-semibold text-sm">{commitment.goalTitle}</div>
                    <Badge
                      variant="outline"
                      className={`text-xs ${
                        commitment.urgency === "high"
                          ? "border-red-500 text-red-600 dark:text-red-300"
                          : commitment.urgency === "medium"
                          ? "border-amber-500 text-amber-600 dark:text-amber-300"
                          : "border-emerald-500 text-emerald-600 dark:text-emerald-300"
                      }`}
                    >
                      {commitment.urgency === "high"
                        ? t.aiUrgencyHigh
                        : commitment.urgency === "medium"
                        ? t.aiUrgencyMedium
                        : t.aiUrgencyLow}
                    </Badge>
                  </div>
                  {commitment.recommendedUnits > 0 && (
                    <div className="text-xs font-medium text-neutral-600 dark:text-neutral-300">
                      {t.aiRecommended}: {commitment.recommendedUnits} {commitment.unitLabel}
                    </div>
                  )}
                  <div className="text-xs leading-snug text-neutral-500 dark:text-neutral-400">
                    {commitment.message}
                  </div>
                </div>
              ))
            )}
          </CardContent>
        </SurfaceCard>

        <SurfaceCard>
          <CardHeader className="pb-2">
            <CardTitle className="flex items-center gap-2 text-base">
              <Lightbulb className="h-4 w-4" /> {t.aiSuggestions}
            </CardTitle>
          </CardHeader>
          <CardContent>
            {snapshot.suggestions.length === 0 ? (
              <div className="text-sm text-neutral-500">{t.aiNoSuggestions}</div>
            ) : (
              <ul className="space-y-3">
                {snapshot.suggestions.map(s => (
                  <li key={s.id} className="rounded-lg border-l-4 border-neutral-200 bg-neutral-100/70 p-3 dark:border-neutral-700 dark:bg-neutral-900/60">
                    <div className="text-sm font-semibold">{s.headline}</div>
                    <div className="text-xs text-neutral-600 dark:text-neutral-400 leading-snug">{s.detail}</div>
                  </li>
                ))}
              </ul>
            )}
          </CardContent>
        </SurfaceCard>
      </div>
    </div>
  );
}

function QuickAdd({ onAdd, label }: { onAdd: (title: string) => void; label: string }) {
  const [val, setVal] = useState("");
  return (
    <div className="flex w-full flex-col gap-2 sm:flex-row">
      <Input
        value={val}
        onChange={(e)=>setVal(e.target.value)}
        placeholder={`${label} (Alt+N)`}
        className="flex-1"
      />
      <Button onClick={() => { if(val.trim()){ onAdd(val.trim()); setVal(""); } }}>{label}</Button>
    </div>
  );
}

function TaskRow({
  task,
  toggle,
  focus,
  focusLabel,
  onEdit,
  onDelete,
  t,
}: {
  task: Task;
  toggle: (id: string)=>void;
  focus?: boolean;
  focusLabel?: string;
  onEdit?: () => void;
  onDelete?: () => void;
  t: any;
}) {
  const workload = Math.min(100, Math.max(10, Math.round((task.estimateMin / 120) * 100)));
  const priorityStyles: Record<Task["priority"], string> = {
    high: "border-rose-400/70 bg-gradient-to-r from-rose-100/80 via-transparent to-transparent dark:from-rose-500/20",
    med: "border-sky-300/70 bg-gradient-to-r from-sky-100/60 via-transparent to-transparent dark:from-sky-500/10",
    low: "border-amber-200/70 bg-gradient-to-r from-amber-100/50 via-transparent to-transparent dark:from-amber-500/10",
  };
  const dueLabel = task.dueDate ? format(new Date(task.dueDate), 'dd/MM') : undefined;
  return (
    <div
      className={`relative overflow-hidden rounded-2xl border p-3 shadow-sm transition-all duration-200 ${
        priorityStyles[task.priority]
      } ${
        task.done ? 'opacity-60' : 'hover:-translate-y-[1px] hover:shadow-lg'
      } ${focus ? 'ring-2 ring-emerald-400/60 dark:ring-emerald-500/50' : ''}`}
    >
      <div className="flex items-start justify-between gap-3">
        <div className="flex items-start gap-3">
          <Checkbox checked={task.done} onCheckedChange={() => toggle(task.id)} />
          <div className={`space-y-1 ${task.done ? 'line-through text-neutral-400' : ''}`}>
            <div className="flex flex-wrap items-center gap-2 text-sm font-semibold">
              <span>{task.title}</span>
              {task.priority === 'high' && <Badge variant="destructive">{t.priorityHigh}</Badge>}
              {task.priority === 'med' && <Badge variant="secondary">{t.priorityMedium}</Badge>}
              {task.priority === 'low' && <Badge variant="outline">{t.priorityLow}</Badge>}
              {focus && (
                <Badge variant="outline" className="border-emerald-500 text-emerald-600 dark:text-emerald-300">
                  {focusLabel ?? 'Focus IA'}
                </Badge>
              )}
            </div>
            <div className="flex flex-wrap gap-2 text-xs text-neutral-500 dark:text-neutral-400">
              <span>{task.project}</span>
              <span>· {task.estimateMin} min</span>
              {dueLabel && <span>· {t.due} {dueLabel}</span>}
            </div>
            {task.notes && (
              <div className="whitespace-pre-line text-xs text-neutral-600 dark:text-neutral-300">
                {task.notes}
              </div>
            )}
            <div className="h-1 w-full overflow-hidden rounded-full bg-white/50 dark:bg-neutral-800">
              <div
                className="h-full bg-gradient-to-r from-emerald-400 via-emerald-500 to-sky-500"
                style={{ width: `${workload}%` }}
              />
            </div>
          </div>
        </div>
        <div className="flex flex-col items-end gap-2 text-xs">
          <Badge>{task.points} pts</Badge>
          {(onEdit || onDelete) && (
            <div className="flex items-center gap-1">
              {onEdit && (
                <Button variant="ghost" size="icon" onClick={onEdit} aria-label={`${t.edit} ${task.title}`}>
                  <Pencil className="h-4 w-4" />
                </Button>
              )}
              {onDelete && (
                <Button variant="ghost" size="icon" onClick={onDelete} aria-label={`${t.delete} ${task.title}`}>
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

function ProjectChatbot({
  tasks,
  goals,
  aiFocus,
  projects,
  t,
  lang,
}: {
  tasks: Task[];
  goals: Goal[];
  aiFocus: AiFocusState;
  projects: string[];
  t: any;
  lang: "es" | "en";
}) {
  const surface = useSurface();
  const [messages, setMessages] = useState<ChatMessage[]>(() => [
    { id: uuidv4(), role: "bot", text: t.chatbotGreet, timestamp: new Date().toISOString() },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement | null>(null);

  type ProjectInsight = {
    name: string;
    tasks: Task[];
    goals: Goal[];
    overdue: Task[];
    dueSoon: Task[];
    high: Task[];
    focus: Task[];
    estimate: number;
    goalProgress: { goal: Goal; completion: number }[];
  };

  const undone = useMemo(() => tasks.filter(task => !task.done), [tasks]);
  const today = useMemo(() => todayISO().slice(0, 10), []);
  const focusSet = useMemo(() => {
    return aiFocus.date && aiFocus.date.slice(0, 10) === today ? new Set(aiFocus.taskIds) : new Set<string>();
  }, [aiFocus.date, aiFocus.taskIds, today]);

  const overdue = useMemo(
    () =>
      undone
        .filter(task => task.dueDate && task.dueDate.slice(0, 10) < today)
        .sort((a, b) => (a.dueDate || "").localeCompare(b.dueDate || "")),
    [undone, today],
  );

  const dueSoon = useMemo(
    () =>
      undone
        .filter(task => task.dueDate && task.dueDate.slice(0, 10) >= today)
        .sort((a, b) => (a.dueDate || "").localeCompare(b.dueDate || "")),
    [undone, today],
  );

  const highPriority = useMemo(
    () => undone.filter(task => task.priority === "high").sort((a, b) => a.title.localeCompare(b.title, lang)),
    [undone, lang],
  );

  const totalEstimate = useMemo(
    () => undone.reduce((acc, task) => acc + (Number.isFinite(task.estimateMin) ? task.estimateMin : 30), 0),
    [undone],
  );

  const goalsProgress = useMemo(() => {
    return goals.map(goal => {
      const total = goal.history.reduce((sum, entry) => sum + entry.units, 0);
      const completion = goal.targetUnits ? Math.round((total / goal.targetUnits) * 100) : 0;
      return { goal, completion };
    });
  }, [goals]);

  const projectInsights = useMemo<ProjectInsight[]>(() => {
    const map = new Map<string, ProjectInsight>();
    const ensure = (name?: string) => {
      const key = (name && name.trim()) || t.defaultProjectName || "Proyecto";
      if (!map.has(key)) {
        map.set(key, {
          name: key,
          tasks: [],
          goals: [],
          overdue: [],
          dueSoon: [],
          high: [],
          focus: [],
          estimate: 0,
          goalProgress: [],
        });
      }
      return map.get(key)!;
    };
    const todayIso = todayISO();
    undone.forEach(task => {
      const bucket = ensure(task.project);
      bucket.tasks.push(task);
      bucket.estimate += Number.isFinite(task.estimateMin) ? task.estimateMin : 30;
      if (task.priority === "high") bucket.high.push(task);
      if (focusSet.has(task.id)) bucket.focus.push(task);
      if (task.dueDate) {
        const diff = diffDays(todayIso, task.dueDate);
        if (diff < 0) bucket.overdue.push(task);
        else if (diff <= 3) bucket.dueSoon.push(task);
      }
    });
    goals.forEach(goal => {
      const bucket = ensure(goal.project);
      bucket.goals.push(goal);
      const total = goal.history.reduce((sum, entry) => sum + entry.units, 0);
      const completion = goal.targetUnits ? Math.round((total / goal.targetUnits) * 100) : 0;
      bucket.goalProgress.push({ goal, completion });
    });
    projects.forEach(name => ensure(name));
    return Array.from(map.values())
      .map(info => ({
        ...info,
        overdue: info.overdue.sort((a, b) => (a.dueDate || "").localeCompare(b.dueDate || "")),
        dueSoon: info.dueSoon.sort((a, b) => (a.dueDate || "").localeCompare(b.dueDate || "")),
        high: info.high.sort((a, b) => a.title.localeCompare(b.title, lang, { sensitivity: "base" })),
        focus: info.focus.sort((a, b) => a.title.localeCompare(b.title, lang, { sensitivity: "base" })),
        goalProgress: info.goalProgress.sort((a, b) => b.completion - a.completion),
      }))
      .sort((a, b) => a.name.localeCompare(b.name, lang, { sensitivity: "base" }));
  }, [projects, undone, goals, focusSet, lang, t.defaultProjectName]);

  useEffect(() => {
    if (!loading) {
      scrollRef.current?.scrollTo({ top: scrollRef.current.scrollHeight, behavior: "smooth" });
    }
  }, [messages, loading]);

  useEffect(() => {
    setMessages(prev => {
      if (prev.length === 1 && prev[0]?.role === "bot") {
        return [{ ...prev[0], text: t.chatbotGreet }];
      }
      return prev;
    });
  }, [t.chatbotGreet]);

  const dictionary = useMemo(() => {
    if (lang === "es") {
      return {
        summary: (pending: number, mins: number, goalsCount: number) =>
          `Quedan ${pending} tareas (~${mins} min) y ${goalsCount} metas activas.`,
        focusHeader: "Enfoque IA:",
        highPriority: "Prioridad alta:",
        dueSoon: "Por vencer:",
        overdue: "Atrasadas:",
        goalsHeader: "Pulso de metas:",
        effort: (mins: number) => `Carga aproximada: ${mins} min de trabajo concentrado.`,
        askMore: "Pídeme más detalles por proyecto, prioridad o metas.",
        noData: t.chatbotNoData,
        calendarHint: "Conecta Google Calendar para cruzar compromisos.",
        projectOverview: (info: ProjectInsight) => {
          const tasksLabel = info.tasks.length === 1 ? "tarea" : "tareas";
          const parts = [`${info.tasks.length} ${tasksLabel}`];
          if (info.overdue.length) parts.push(`${info.overdue.length} atrasadas`);
          else if (info.dueSoon.length) parts.push(`${info.dueSoon.length} por vencer`);
          const hours = Math.round(info.estimate / 60);
          if (hours) parts.push(`~${hours} h`);
          return `Proyecto ${info.name}: ${parts.join(" · ")}`;
        },
        projectFocusTitle: "Enfoque para este proyecto:",
        projectPrompt: "Proyectos disponibles:",
        projectNoProjects: "Aún no hay proyectos guardados.",
        projectNoMatch: "No encontré datos para ese proyecto. Revisa el nombre.",
      };
    }
    return {
      summary: (pending: number, mins: number, goalsCount: number) =>
        `${pending} tasks pending (~${mins} min) with ${goalsCount} active goals.`,
      focusHeader: "AI focus:",
      highPriority: "High priority:",
      dueSoon: "Due soon:",
      overdue: "Overdue:",
      goalsHeader: "Goal pulse:",
      effort: (mins: number) => `Rough effort: ${mins} min of focused work.`,
      askMore: "Ask for project, priority, or goal details.",
      noData: t.chatbotNoData,
      calendarHint: "Connect Google Calendar to cross-check commitments.",
      projectOverview: (info: ProjectInsight) => {
        const tasksLabel = info.tasks.length === 1 ? "task" : "tasks";
        const parts = [`${info.tasks.length} ${tasksLabel}`];
        if (info.overdue.length) parts.push(`${info.overdue.length} overdue`);
        else if (info.dueSoon.length) parts.push(`${info.dueSoon.length} due soon`);
        const hours = Math.round(info.estimate / 60);
        if (hours) parts.push(`~${hours} h`);
        return `Project ${info.name}: ${parts.join(" · ")}`;
      },
      projectFocusTitle: "Project focus:",
      projectPrompt: "Available projects:",
      projectNoProjects: "No projects saved yet.",
      projectNoMatch: "I couldn't find that project. Try another name.",
    };
  }, [lang, t]);

  const formatTask = useCallback(
    (task: Task) => {
      const due = task.dueDate ? format(new Date(task.dueDate), lang === "es" ? "dd/MM" : "MMM d") : null;
      const priorityLabel =
        task.priority === "high" ? (lang === "es" ? "alta" : "high") : task.priority === "med" ? (lang === "es" ? "media" : "medium") : lang === "es" ? "baja" : "low";
      return `• ${task.title} (${task.project}${due ? ` · ${lang === "es" ? "vence" : "due"} ${due}` : ""} · ${priorityLabel})`;
    },
    [lang],
  );

  const formatGoal = useCallback(
    ({ goal, completion }: { goal: Goal; completion: number }) =>
      `• ${goal.title} (${goal.project}) · ${completion}%`,
    [],
  );

  const buildReply = useCallback(
    (message: string) => {
      if (undone.length === 0 && goals.length === 0) {
        return dictionary.noData;
      }

      const normalized = message.toLowerCase();
      const lines: string[] = [dictionary.summary(undone.length, totalEstimate, goals.length)];

      const showFocus = focusSet.size > 0 ? undone.filter(task => focusSet.has(task.id)).slice(0, 3) : [];

      if (normalized.includes("calendar") || normalized.includes("calendario")) {
        lines.push(dictionary.calendarHint);
      }

      if (normalized.includes("meta") || normalized.includes("goal")) {
        if (goalsProgress.length === 0) {
          lines.push(dictionary.noData);
        } else {
          lines.push(dictionary.goalsHeader);
          goalsProgress
            .sort((a, b) => b.completion - a.completion)
            .slice(0, 3)
            .forEach(entry => lines.push(formatGoal(entry)));
        }
      }

      if (normalized.includes("prioridad") || normalized.includes("priority")) {
        const slice = highPriority.slice(0, 3);
        if (slice.length) {
          lines.push(dictionary.highPriority);
          slice.forEach(task => lines.push(formatTask(task)));
        }
      }

      if (normalized.includes("vence") || normalized.includes("due") || normalized.includes("deadline")) {
        const slice = dueSoon.slice(0, 3);
        if (slice.length) {
          lines.push(dictionary.dueSoon);
          slice.forEach(task => lines.push(formatTask(task)));
        }
        if (overdue.length) {
          lines.push(dictionary.overdue);
          overdue.slice(0, 3).forEach(task => lines.push(formatTask(task)));
        }
      }

      if (normalized.includes("tiempo") || normalized.includes("time") || normalized.includes("carga") || normalized.includes("effort")) {
        lines.push(dictionary.effort(totalEstimate));
      }

      const projectMatches = projectInsights.filter(info => {
        const normalizedName = info.name.toLowerCase();
        if (!normalizedName) return false;
        if (normalized.includes(normalizedName)) return true;
        return normalizedName
          .split(/[^a-z0-9áéíóúüñ]+/)
          .filter(token => token.length > 3)
          .some(token => normalized.includes(token));
      });

      if (projectMatches.length) {
        projectMatches.forEach(info => {
          lines.push(dictionary.projectOverview(info));
          const focusGroup = info.focus.length ? info.focus : info.high;
          if (focusGroup.length) {
            lines.push(dictionary.projectFocusTitle);
            focusGroup.slice(0, 3).forEach(task => lines.push(formatTask(task)));
          }
          if (info.dueSoon.length) {
            lines.push(dictionary.dueSoon);
            info.dueSoon.slice(0, 3).forEach(task => lines.push(formatTask(task)));
          }
          if (info.overdue.length) {
            lines.push(dictionary.overdue);
            info.overdue.slice(0, 3).forEach(task => lines.push(formatTask(task)));
          }
          if (info.goalProgress.length) {
            lines.push(dictionary.goalsHeader);
            info.goalProgress.slice(0, 3).forEach(entry => lines.push(formatGoal(entry)));
          }
        });
      } else if (normalized.includes("proyecto") || normalized.includes("project")) {
        if (projectInsights.length) {
          if (normalized.trim().split(/\s+/).length > 1) {
            lines.push(dictionary.projectNoMatch);
          }
          lines.push(dictionary.projectPrompt);
          projectInsights.slice(0, 5).forEach(info => {
            lines.push(`• ${info.name}`);
          });
        } else {
          lines.push(dictionary.projectNoProjects);
        }
      }

      if (lines.length === 1) {
        if (showFocus.length) {
          lines.push(dictionary.focusHeader);
          showFocus.forEach(task => lines.push(formatTask(task)));
        } else if (highPriority.length) {
          lines.push(dictionary.highPriority);
          highPriority.slice(0, 3).forEach(task => lines.push(formatTask(task)));
        }
        if (dueSoon.length) {
          lines.push(dictionary.dueSoon);
          dueSoon.slice(0, 2).forEach(task => lines.push(formatTask(task)));
        }
        if (goalsProgress.length) {
          lines.push(dictionary.goalsHeader);
          goalsProgress.slice(0, 2).forEach(entry => lines.push(formatGoal(entry)));
        }
      }

      return lines.join("\n");
    },
    [
      dictionary,
      undone.length,
      goals.length,
      focusSet,
      undone,
      highPriority,
      dueSoon,
      overdue,
      goalsProgress,
      totalEstimate,
      projectInsights,
      formatTask,
      formatGoal,
    ],
  );

  const sendMessage = useCallback(() => {
    if (loading) return;
    const trimmed = input.trim();
    if (!trimmed) return;
    setMessages(prev => [...prev, { id: uuidv4(), role: "user", text: trimmed, timestamp: new Date().toISOString() }]);
    setInput("");
    setLoading(true);
    setTimeout(() => {
      const reply = buildReply(trimmed);
      setMessages(prev => [...prev, { id: uuidv4(), role: "bot", text: reply, timestamp: new Date().toISOString() }]);
      setLoading(false);
    }, 350);
  }, [input, buildReply, loading]);

  return (
    <div className="grid gap-4 lg:grid-cols-[minmax(0,2fr),minmax(0,1fr)]">
      <SurfaceCard className="flex h-full flex-col gap-4 p-4 sm:p-6">
        <div className="space-y-1">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Sparkles className="h-5 w-5 text-emerald-500" /> {t.chatbotTitle}
          </CardTitle>
          <p className="text-sm text-neutral-500 dark:text-neutral-400">{t.chatbotIntro}</p>
        </div>
        <div ref={scrollRef} className={cx(surface.subtle, "flex-1 space-y-3 overflow-y-auto rounded-3xl p-4") }>
          {messages.length === 0 && !loading && (
            <div className="text-sm text-neutral-500 dark:text-neutral-400">{t.chatbotEmpty}</div>
          )}
          {messages.map(msg => (
            <div
              key={msg.id}
              className={cx(
                "max-w-[85%] rounded-2xl px-4 py-2 text-sm leading-relaxed shadow-sm",
                msg.role === "bot"
                  ? cx(surface.accentSoft, "text-neutral-800 dark:text-neutral-100")
                  : "ml-auto bg-neutral-900 text-white dark:bg-neutral-100 dark:text-neutral-900",
              )}
            >
              {msg.text.split("\n").map((line, idx) => (
                <p key={idx} className={idx === 0 ? "" : "mt-1"}>
                  {line}
                </p>
              ))}
            </div>
          ))}
          {loading && (
            <div className={cx(surface.accentSoft, "inline-flex items-center gap-2 rounded-2xl px-4 py-2 text-sm text-neutral-700 dark:text-neutral-100")}> 
              <Sparkles className="h-4 w-4 animate-pulse" /> {t.chatbotThinking}
            </div>
          )}
        </div>
        <div className="flex flex-col gap-2">
          <Textarea
            value={input}
            onChange={e => setInput(e.target.value)}
            placeholder={t.chatbotPlaceholder}
            rows={2}
            className={cx(surface.fieldArea, "min-h-[88px]")}
            onKeyDown={e => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
          />
          <div className="flex items-center justify-between gap-2">
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{dictionary.askMore}</div>
            <Button onClick={sendMessage} className="rounded-full px-4" disabled={!input.trim() || loading}>
              <Send className="mr-2 h-4 w-4" /> {t.send ?? "Enviar"}
            </Button>
          </div>
        </div>
      </SurfaceCard>

      <SurfaceCard className="space-y-4 p-4 sm:p-6">
        <div>
          <CardTitle className="text-base">{lang === "es" ? "Resumen rápido" : "Quick summary"}</CardTitle>
          <p className="text-xs text-neutral-500 dark:text-neutral-400">{dictionary.summary(undone.length, totalEstimate, goals.length)}</p>
        </div>
        <div className="grid grid-cols-2 gap-3 text-sm">
          <div className={cx(surface.subtle, "rounded-2xl p-3 text-center") }>
            <div className="text-2xl font-semibold">{undone.length}</div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{lang === "es" ? "Tareas" : "Tasks"}</div>
          </div>
          <div className={cx(surface.subtle, "rounded-2xl p-3 text-center") }>
            <div className="text-2xl font-semibold">{goals.length}</div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{lang === "es" ? "Metas" : "Goals"}</div>
          </div>
          <div className={cx(surface.subtle, "rounded-2xl p-3 text-center") }>
            <div className="text-2xl font-semibold">{highPriority.length}</div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{lang === "es" ? "Alta prioridad" : "High priority"}</div>
          </div>
          <div className={cx(surface.subtle, "rounded-2xl p-3 text-center") }>
            <div className="text-2xl font-semibold">{Math.round(totalEstimate / 60)}</div>
            <div className="text-xs text-neutral-500 dark:text-neutral-400">{lang === "es" ? "Horas estimadas" : "Estimated hours"}</div>
          </div>
        </div>
        <div className="space-y-2">
          <div className="text-xs font-semibold uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
            {lang === "es" ? "Siguiente foco" : "Next focus"}
          </div>
          <ul className="space-y-1 text-sm text-neutral-700 dark:text-neutral-200">
            {(focusSet.size ? undone.filter(task => focusSet.has(task.id)) : highPriority)
              .slice(0, 3)
              .map(task => {
                const due = task.dueDate ? format(new Date(task.dueDate), lang === "es" ? "dd/MM" : "MMM d") : null;
                return (
                  <li key={task.id} className="leading-tight">
                    {task.title} ({task.project}{due ? ` · ${due}` : ""})
                  </li>
                );
              })}
          </ul>
        </div>
        <div className="space-y-2">
          <div className="text-xs font-semibold uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
            {lang === "es" ? "Proyectos activos" : "Active projects"}
          </div>
          <ul className="space-y-2 text-sm text-neutral-700 dark:text-neutral-200">
            {projectInsights.slice(0, 4).map(info => {
              const hours = Math.round(info.estimate / 60);
              const statusLabel = info.overdue.length
                ? lang === "es" ? `${info.overdue.length} atrasadas` : `${info.overdue.length} overdue`
                : info.dueSoon.length
                ? lang === "es" ? `${info.dueSoon.length} próximas` : `${info.dueSoon.length} due soon`
                : lang === "es" ? `${info.tasks.length} tareas` : `${info.tasks.length} tasks`;
              return (
                <li key={info.name} className={cx(surface.subtle, "rounded-2xl px-3 py-2 leading-tight") }>
                  <div className="flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-neutral-500 dark:text-neutral-400">
                    <span>{info.name}</span>
                    <span>{statusLabel}</span>
                  </div>
                  <div className="text-sm font-medium text-neutral-800 dark:text-neutral-100">
                    {hours > 0
                      ? lang === "es"
                        ? `~${hours} h de carga`
                        : `~${hours} h of work`
                      : lang === "es"
                      ? "Sin estimaciones"
                      : "No estimates"}
                  </div>
                </li>
              );
            })}
            {projectInsights.length === 0 && (
              <li className="text-xs text-neutral-500 dark:text-neutral-400">
                {lang === "es"
                  ? "Agrega proyectos desde tareas, metas o ajustes."
                  : "Add projects from tasks, goals, or settings."}
              </li>
            )}
          </ul>
        </div>
      </SurfaceCard>
    </div>
  );
}

function TaskFilters({
  t,
  projects,
  projectValue,
  onProjectChange,
  priorityValue,
  onPriorityChange,
  searchValue,
  onSearchChange,
  showCompleted,
  onToggleCompleted,
  focusOnly,
  onToggleFocus,
  onReset,
}: {
  t: any;
  projects: string[];
  projectValue: string;
  onProjectChange: (value: string) => void;
  priorityValue: string;
  onPriorityChange: (value: string) => void;
  searchValue: string;
  onSearchChange: (value: string) => void;
  showCompleted: boolean;
  onToggleCompleted: (value: boolean) => void;
  focusOnly: boolean;
  onToggleFocus: (value: boolean) => void;
  onReset: () => void;
}) {
  const surface = useSurface();
  const spacing = surface.density === "compact" ? "gap-3" : surface.density === "cozy" ? "gap-4" : "gap-5";

  return (
    <SurfaceCard className="flex flex-col gap-5 p-4 sm:p-5">
      <div className={`grid grid-cols-1 ${spacing} sm:grid-cols-2 xl:grid-cols-4`}>
        <div className="space-y-1">
          <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.filters}</Label>
          <Select value={projectValue} onValueChange={onProjectChange}>
            <SelectTrigger className={cx(surface.field, "h-11") }>
              <SelectValue placeholder={t.project} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">{t.allProjects}</SelectItem>
              {projects.map(project => (
                <SelectItem key={project} value={project}>{project}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-1">
          <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.priority}</Label>
          <Select value={priorityValue} onValueChange={onPriorityChange}>
            <SelectTrigger className={cx(surface.field, "h-11") }>
              <SelectValue placeholder={t.priority} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">{t.allPriorities}</SelectItem>
              <SelectItem value="high">{t.priorityHigh}</SelectItem>
              <SelectItem value="med">{t.priorityMedium}</SelectItem>
              <SelectItem value="low">{t.priorityLow}</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-1">
          <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.searchPlaceholder}</Label>
          <Input
            value={searchValue}
            onChange={e => onSearchChange(e.target.value)}
            placeholder={t.searchPlaceholder}
            className={cx(surface.field, "h-11")}
          />
        </div>
        <div className="space-y-2">
          <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.focusAndState}</Label>
          <div className={cx(surface.subtle, "flex flex-wrap items-center gap-3 rounded-2xl px-3 py-2 text-xs") }>
            <label className="flex items-center gap-2">
              <Switch checked={showCompleted} onCheckedChange={v => onToggleCompleted(!!v)} />
              <span>{t.showCompleted}</span>
            </label>
            <label className="flex items-center gap-2">
              <Switch checked={focusOnly} onCheckedChange={v => onToggleFocus(!!v)} />
              <span>{t.showFocusOnly}</span>
            </label>
          </div>
        </div>
      </div>
      <div className="flex flex-wrap items-center justify-between gap-3">
        <div className="text-xs text-neutral-500 dark:text-neutral-400">{t.filterHint}</div>
        <Button variant="ghost" onClick={onReset} className="rounded-full px-4">
          <Filter className="mr-2 h-4 w-4" /> {t.clearFilters}
        </Button>
      </div>
    </SurfaceCard>
  );
}

function BulkTaskDialog({
  t,
  projects,
  onAddProject,
  onSubmit,
  fallbackProject,
}: {
  t: any;
  projects: string[];
  onAddProject: (name: string) => void;
  onSubmit: (items: Omit<Task, "id" | "createdAt" | "done">[]) => void;
  fallbackProject: string;
}) {
  const [open, setOpen] = useState(false);
  const [raw, setRaw] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [feedback, setFeedback] = useState<string | null>(null);
  const surface = useSurface();

  const example = `${projects[0] ?? fallbackProject} | ${t.titleLbl} | 45 | high`;

  function parseLine(line: string) {
    const parts = line.split("|").map(p => p.trim());
    if (parts.length < 2) throw new Error(t.titleLbl);
    const [projectRaw, titleRaw, minutesRaw, priorityRaw, dueRaw] = parts;
    const project = projectRaw || projects[0] || fallbackProject;
    const title = titleRaw;
    if (!title) throw new Error(t.titleLbl);
    const minutes = Math.max(5, parseInt(minutesRaw || "30", 10) || 30);
    const priorityKey = (priorityRaw || "med").toLowerCase();
    const priority: Task["priority"] = priorityKey.startsWith("h")
      ? "high"
      : priorityKey.startsWith("l")
      ? "low"
      : "med";
    const dueDate = dueRaw ? toISODate(dueRaw) : undefined;
    onAddProject(project);
    return {
      title,
      project,
      estimateMin: minutes,
      points: Math.max(10, Math.round(minutes / 15) * 5),
      priority,
      dueDate,
    } satisfies Omit<Task, "id" | "createdAt" | "done">;
  }

  function handleImport() {
    try {
      const lines = raw.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      if (!lines.length) {
        setError(t.bulkHint);
        return;
      }
      const items = lines.map(parseLine);
      onSubmit(items);
      setFeedback(t.bulkParsed ? t.bulkParsed(items.length) : `${items.length}`);
      setError(null);
      setRaw("");
      setOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    }
  }

  return (
    <div className="flex flex-col gap-1">
      <Dialog open={open} onOpenChange={(state) => { setOpen(state); if (!state) setError(null); }}>
        <DialogTrigger asChild>
          <Button variant="outline" className="flex items-center gap-2">
            <ListPlus className="h-4 w-4" /> {t.bulkTasks}
          </Button>
        </DialogTrigger>
        <DialogContent className={cx("max-w-xl", surface.dialog)} style={surface.dialogStyle}>
          <DialogHeader>
            <DialogTitle>{t.bulkTasks}</DialogTitle>
          </DialogHeader>
          <div className="space-y-3">
            <div className="text-sm text-neutral-600 dark:text-neutral-300">{t.bulkHint}</div>
            <Textarea
              rows={6}
              value={raw}
              onChange={(e)=>setRaw(e.target.value)}
              placeholder={`${t.importExample}: ${example}`}
              className={cx(surface.fieldArea, "min-h-[180px]")}
            />
            {error && <div className="text-sm text-rose-500">{error}</div>}
            <div className="flex justify-end gap-2">
              <Button variant="ghost" onClick={() => { setOpen(false); }}>{t.cancel}</Button>
              <Button onClick={handleImport}>{t.add}</Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
      {feedback && <div className="text-xs text-emerald-600 dark:text-emerald-300">{feedback}</div>}
    </div>
  );
}

function BulkGoalDialog({
  t,
  projects,
  onAddProject,
  onSubmit,
  fallbackProject,
}: {
  t: any;
  projects: string[];
  onAddProject: (name: string) => void;
  onSubmit: (items: Omit<Goal, "id" | "createdAt" | "history">[]) => void;
  fallbackProject: string;
}) {
  const [open, setOpen] = useState(false);
  const [raw, setRaw] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [feedback, setFeedback] = useState<string | null>(null);
  const surface = useSurface();

  const example = `${projects[0] ?? fallbackProject} | ${t.titleLbl} | 10 | ${t.unitLabel}`;

  function parseLine(line: string) {
    const parts = line.split("|").map(p => p.trim());
    if (parts.length < 3) throw new Error(t.bulkGoalHint);
    const [projectRaw, titleRaw, unitsRaw, labelRaw, dueRaw] = parts;
    const project = projectRaw || projects[0] || fallbackProject;
    const title = titleRaw;
    if (!title) throw new Error(t.titleLbl);
    const targetUnits = Math.max(1, parseInt(unitsRaw || "1", 10) || 1);
    const unitLabel = labelRaw || t.unitLabel;
    const dueDate = dueRaw ? toISODate(dueRaw) : undefined;
    onAddProject(project);
    return { title, project, targetUnits, unitLabel, dueDate } satisfies Omit<Goal, "id" | "createdAt" | "history">;
  }

  function handleImport() {
    try {
      const lines = raw.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
      if (!lines.length) {
        setError(t.bulkGoalHint);
        return;
      }
      const items = lines.map(parseLine);
      onSubmit(items);
      setFeedback(t.bulkParsed ? t.bulkParsed(items.length) : `${items.length}`);
      setError(null);
      setRaw("");
      setOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    }
  }

  return (
    <div className="flex flex-col gap-1">
      <Dialog open={open} onOpenChange={(state) => { setOpen(state); if (!state) setError(null); }}>
        <DialogTrigger asChild>
          <Button variant="outline" className="flex items-center gap-2">
            <ListPlus className="h-4 w-4" /> {t.bulkGoals}
          </Button>
        </DialogTrigger>
        <DialogContent className={cx("max-w-xl", surface.dialog)} style={surface.dialogStyle}>
          <DialogHeader>
            <DialogTitle>{t.bulkGoals}</DialogTitle>
          </DialogHeader>
          <div className="space-y-3">
            <div className="text-sm text-neutral-600 dark:text-neutral-300">{t.bulkGoalHint}</div>
            <Textarea
              rows={5}
              value={raw}
              onChange={(e)=>setRaw(e.target.value)}
              placeholder={`${t.importExample}: ${example}`}
              className={cx(surface.fieldArea, "min-h-[150px]")}
            />
            {error && <div className="text-sm text-rose-500">{error}</div>}
            <div className="flex justify-end gap-2">
              <Button variant="ghost" onClick={() => { setOpen(false); }}>{t.cancel}</Button>
              <Button onClick={handleImport}>{t.add}</Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
      {feedback && <div className="text-xs text-emerald-600 dark:text-emerald-300">{feedback}</div>}
    </div>
  );
}

function TaskForm({ onCreate, t, projects, onAddProject, fallbackProject }: { onCreate: (t: Omit<Task, "id" | "createdAt" | "done">) => void; t:any; projects: string[]; onAddProject: (name: string) => void; fallbackProject: string }) {
  const [title, setTitle] = useState("");
  const [project, setProject] = useState(projects[0] ?? fallbackProject);
  const [estimateMin, setEstimateMin] = useState(50);
  const [points, setPoints] = useState(20);
  const [dueDate, setDueDate] = useState<string | undefined>();
  const [notes, setNotes] = useState("");
  const [priority, setPriority] = useState<"low"|"med"|"high">("med");
  const surface = useSurface();

  useEffect(() => {
    setProject(prev => {
      if (!projects.length) {
        return prev || fallbackProject;
      }
      if (!prev || !projects.some(p => p === prev)) {
        return projects[0];
      }
      return prev;
    });
  }, [projects, fallbackProject]);

  const projectOptions = useMemo(() => {
    if (!project || projects.includes(project)) return projects;
    return [...projects, project];
  }, [projects, project]);

  const handleProjectChange = (value: string) => {
    if (value === NEW_PROJECT_VALUE) {
      const name = prompt(t.newProjectPrompt ?? t.newProject ?? "Nuevo proyecto");
      const normalized = name?.trim();
      if (normalized) {
        onAddProject(normalized);
        setProject(normalized);
      }
      return;
    }
    setProject(value);
  };

  function submit() {
    if (!title.trim()) return;
    onAddProject(project);
    onCreate({ title: title.trim(), project, estimateMin, points, notes: notes.trim() || undefined, dueDate: toISODate(dueDate), priority });
    setTitle(""); setNotes(""); setEstimateMin(50); setPoints(20); setDueDate(undefined); setPriority("med");
  }

  return (
    <CardContent className={cx(surface.density === "compact" ? "space-y-2.5" : surface.density === "cozy" ? "space-y-3.5" : "space-y-4")}
    >
      <div className="space-y-1">
        <Label>{t.titleLbl}</Label>
        <Input value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Ej. C4.7: interpretar coeficientes" />
      </div>
      <div className="grid grid-cols-2 gap-2">
        <div className="space-y-1">
          <Label>{t.project}</Label>
          <Select value={project} onValueChange={handleProjectChange}>
            <SelectTrigger><SelectValue /></SelectTrigger>
            <SelectContent>
              {projectOptions.map(opt => (
                <SelectItem key={opt} value={opt}>{opt}</SelectItem>
              ))}
              <SelectItem value={NEW_PROJECT_VALUE}>+ {t.newProject ?? "Nuevo proyecto"}</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-1">
          <Label>{t.due}</Label>
          <Input type="date" value={dueDate || ""} onChange={(e) => setDueDate(e.target.value)} />
        </div>
      </div>
      <div className="grid grid-cols-3 gap-2">
        <div className="space-y-1">
          <Label>{t.estimate}</Label>
          <Input type="number" min={5} step={5} value={estimateMin} onChange={(e) => setEstimateMin(parseInt(e.target.value || '0'))} />
        </div>
        <div className="space-y-1">
          <Label>{t.points}</Label>
          <Input type="number" min={5} step={5} value={points} onChange={(e) => setPoints(parseInt(e.target.value || '0'))} />
        </div>
        <div className="space-y-1">
          <Label>{t.priority}</Label>
          <Select value={priority} onValueChange={(v)=>setPriority(v as any)}>
            <SelectTrigger><SelectValue /></SelectTrigger>
            <SelectContent>
              <SelectItem value="low">{t.priorityLow}</SelectItem>
              <SelectItem value="med">{t.priorityMedium}</SelectItem>
              <SelectItem value="high">{t.priorityHigh}</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>
      <div className="space-y-1">
        <Label>{t.notes}</Label>
        <Textarea value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Definición de terminado" />
      </div>
      <Button className="w-full" onClick={submit}>{t.add}</Button>
    </CardContent>
  );
}

function GoalForm({ onCreate, t, projects, onAddProject, fallbackProject }: { onCreate: (g: Omit<Goal, "id" | "createdAt" | "history">) => void; t:any; projects: string[]; onAddProject: (name: string) => void; fallbackProject: string }) {
  const [title, setTitle] = useState("");
  const [project, setProject] = useState(projects[0] ?? fallbackProject);
  const [targetUnits, setTargetUnits] = useState(100);
  const [unitLabel, setUnitLabel] = useState("páginas");
  const [dueDate, setDueDate] = useState<string | undefined>();
  const surface = useSurface();

  useEffect(() => {
    setProject(prev => {
      if (!projects.length) {
        return prev || fallbackProject;
      }
      if (!prev || !projects.some(p => p === prev)) {
        return projects[0];
      }
      return prev;
    });
  }, [projects, fallbackProject]);

  const projectOptions = useMemo(() => {
    if (!project || projects.includes(project)) return projects;
    return [...projects, project];
  }, [projects, project]);

  const handleProjectChange = (value: string) => {
    if (value === NEW_PROJECT_VALUE) {
      const name = prompt(t.newProjectPrompt ?? t.newProject ?? "Nuevo proyecto");
      const normalized = name?.trim();
      if (normalized) {
        onAddProject(normalized);
        setProject(normalized);
      }
      return;
    }
    setProject(value);
  };

  function submit() {
    if (!title.trim()) return;
    onAddProject(project);
    onCreate({ title: title.trim(), project, targetUnits, unitLabel, dueDate: toISODate(dueDate) });
    setTitle(""); setTargetUnits(100); setUnitLabel("páginas"); setDueDate(undefined);
  }

  return (
    <CardContent className={cx(surface.density === "compact" ? "space-y-2.5" : surface.density === "cozy" ? "space-y-3.5" : "space-y-4")}>
      <div className="space-y-1">
        <Label>{t.titleLbl}</Label>
        <Input value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Ej. Paper redes: borrador 1" />
      </div>
      <div className="grid grid-cols-2 gap-2">
        <div className="space-y-1">
          <Label>{t.project}</Label>
          <Select value={project} onValueChange={handleProjectChange}>
            <SelectTrigger><SelectValue /></SelectTrigger>
            <SelectContent>
              {projectOptions.map(opt => (
                <SelectItem key={opt} value={opt}>{opt}</SelectItem>
              ))}
              <SelectItem value={NEW_PROJECT_VALUE}>+ {t.newProject ?? "Nuevo proyecto"}</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-1">
          <Label>{t.goalDate}</Label>
          <Input type="date" value={dueDate || ""} onChange={(e) => setDueDate(e.target.value)} />
        </div>
      </div>
      <div className="grid grid-cols-2 gap-2">
        <div className="space-y-1">
          <Label>{t.goalUnits}</Label>
          <Input type="number" min={1} step={1} value={targetUnits} onChange={(e) => setTargetUnits(parseInt(e.target.value || '0'))} />
        </div>
        <div className="space-y-1">
          <Label>{t.unitLabel}</Label>
          <Input value={unitLabel} onChange={(e) => setUnitLabel(e.target.value)} placeholder="páginas / ejercicios / horas" />
        </div>
      </div>
      <Button className="w-full" onClick={submit}>{t.create}</Button>
      <div className="pt-2">
        <BulkGoalDialog
          t={t}
          projects={projects}
          onAddProject={onAddProject}
          onSubmit={(items) => {
            items.forEach(onCreate);
          }}
          fallbackProject={fallbackProject}
        />
      </div>
    </CardContent>
  );
}

function GoalHistoryList({ goal, onRemove, t }: { goal: Goal; onRemove: (index: number) => void; t: any }) {
  if (!goal.history.length) {
    return <div className="text-xs text-neutral-500 dark:text-neutral-400">{t.emptyHistory}</div>;
  }
  const recent = goal.history.map((entry, idx) => ({ entry, idx })).slice(-5).reverse();
  return (
    <div className="space-y-1">
      {recent.map(({ entry, idx }) => (
        <div
          key={`${entry.date}-${idx}`}
          className="flex items-center justify-between rounded-lg bg-neutral-100/70 px-2 py-1 text-xs dark:bg-neutral-800/60"
        >
          <span>{format(new Date(entry.date), 'dd/MM')} · {entry.units} {goal.unitLabel}</span>
          <Button
            variant="ghost"
            size="icon"
            className="text-rose-500 hover:text-rose-600"
            onClick={() => onRemove(idx)}
            aria-label={t.removeEntry}
          >
            <XCircle className="h-4 w-4" />
          </Button>
        </div>
      ))}
    </div>
  );
}

function TaskEditDialog({
  task,
  open,
  onClose,
  onSubmit,
  projects,
  onAddProject,
  t,
  fallbackProject,
}: {
  task: Task | null;
  open: boolean;
  onClose: () => void;
  onSubmit: (id: string, patch: Partial<Task>) => void;
  projects: string[];
  onAddProject: (name: string) => void;
  t: any;
  fallbackProject: string;
}) {
  const [title, setTitle] = useState("");
  const [project, setProject] = useState(fallbackProject);
  const [estimateMin, setEstimateMin] = useState(30);
  const [points, setPoints] = useState(20);
  const [dueDate, setDueDate] = useState<string>("");
  const [notes, setNotes] = useState("");
  const [priority, setPriority] = useState<Task["priority"]>("med");
  const surface = useSurface();

  useEffect(() => {
    if (!task) return;
    setTitle(task.title);
    setProject(task.project);
    setEstimateMin(task.estimateMin);
    setPoints(task.points);
    setDueDate(task.dueDate ? task.dueDate.slice(0, 10) : "");
    setNotes(task.notes || "");
    setPriority(task.priority);
  }, [task]);

  const projectOptions = useMemo(() => {
    if (!project || projects.includes(project)) return projects;
    return [...projects, project];
  }, [project, projects]);

  const handleProjectChange = (value: string) => {
    if (value === NEW_PROJECT_VALUE) {
      const name = prompt(t.newProjectPrompt ?? t.newProject ?? "Nuevo proyecto");
      const normalized = name?.trim();
      if (normalized) {
        onAddProject(normalized);
        setProject(normalized);
      }
      return;
    }
    setProject(value);
  };

  const handleSave = () => {
    if (!task) return;
    const trimmed = title.trim();
    if (!trimmed) return;
    const safeEstimate = Number.isFinite(estimateMin) ? estimateMin : task.estimateMin;
    const safePoints = Number.isFinite(points) ? points : task.points;
    onAddProject(project);
    onSubmit(task.id, {
      title: trimmed,
      project,
      estimateMin: Math.max(5, safeEstimate),
      points: Math.max(5, safePoints),
      priority,
      dueDate: dueDate ? toISODate(dueDate) : undefined,
      notes: notes.trim() || undefined,
    });
    onClose();
  };

  if (!task) return null;

  return (
    <Dialog open={open} onOpenChange={(state) => { if (!state) onClose(); }}>
      <DialogContent className={cx("max-w-2xl", surface.dialog)} style={surface.dialogStyle}>
        <DialogHeader>
          <DialogTitle>{t.edit}</DialogTitle>
        </DialogHeader>
        <div className="space-y-3">
          <div className="space-y-1">
            <Label>{t.titleLbl}</Label>
            <Input value={title} onChange={(e)=>setTitle(e.target.value)} />
          </div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label>{t.project}</Label>
              <Select value={project} onValueChange={handleProjectChange}>
                <SelectTrigger><SelectValue /></SelectTrigger>
                <SelectContent>
                  {projectOptions.map(opt => (
                    <SelectItem key={opt} value={opt}>{opt}</SelectItem>
                  ))}
                  <SelectItem value={NEW_PROJECT_VALUE}>+ {t.newProject ?? "Nuevo proyecto"}</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label>{t.due}</Label>
              <Input type="date" value={dueDate} onChange={(e)=>setDueDate(e.target.value)} />
            </div>
          </div>
          <div className="grid grid-cols-3 gap-2">
            <div className="space-y-1">
              <Label>{t.estimate}</Label>
              <Input
                type="number"
                value={estimateMin}
                onChange={(e)=>{
                  const value = parseInt(e.target.value || '0', 10);
                  setEstimateMin(Number.isNaN(value) ? 0 : value);
                }}
              />
            </div>
            <div className="space-y-1">
              <Label>{t.points}</Label>
              <Input
                type="number"
                value={points}
                onChange={(e)=>{
                  const value = parseInt(e.target.value || '0', 10);
                  setPoints(Number.isNaN(value) ? 0 : value);
                }}
              />
            </div>
            <div className="space-y-1">
              <Label>{t.priority}</Label>
              <Select value={priority} onValueChange={(value)=> setPriority(value as Task["priority"]) }>
                <SelectTrigger><SelectValue /></SelectTrigger>
                <SelectContent>
                  <SelectItem value="low">{t.priorityLow}</SelectItem>
                  <SelectItem value="med">{t.priorityMedium}</SelectItem>
                  <SelectItem value="high">{t.priorityHigh}</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <div className="space-y-1">
            <Label>{t.notes}</Label>
            <Textarea value={notes} onChange={(e)=>setNotes(e.target.value)} />
          </div>
          <div className="flex justify-end gap-2">
            <Button variant="ghost" onClick={onClose}>{t.cancel}</Button>
            <Button onClick={handleSave}>{t.saveChanges}</Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

function GoalEditDialog({
  goal,
  open,
  onClose,
  onSubmit,
  projects,
  onAddProject,
  t,
  fallbackProject,
}: {
  goal: Goal | null;
  open: boolean;
  onClose: () => void;
  onSubmit: (id: string, patch: Partial<Goal>) => void;
  projects: string[];
  onAddProject: (name: string) => void;
  t: any;
  fallbackProject: string;
}) {
  const [title, setTitle] = useState("");
  const [project, setProject] = useState(fallbackProject);
  const [targetUnits, setTargetUnits] = useState(1);
  const [unitLabel, setUnitLabel] = useState("");
  const [dueDate, setDueDate] = useState<string>("");
  const surface = useSurface();

  useEffect(() => {
    if (!goal) return;
    setTitle(goal.title);
    setProject(goal.project);
    setTargetUnits(goal.targetUnits);
    setUnitLabel(goal.unitLabel);
    setDueDate(goal.dueDate ? goal.dueDate.slice(0, 10) : "");
  }, [goal]);

  const projectOptions = useMemo(() => {
    if (!project || projects.includes(project)) return projects;
    return [...projects, project];
  }, [project, projects]);

  const handleProjectChange = (value: string) => {
    if (value === NEW_PROJECT_VALUE) {
      const name = prompt(t.newProjectPrompt ?? t.newProject ?? "Nuevo proyecto");
      const normalized = name?.trim();
      if (normalized) {
        onAddProject(normalized);
        setProject(normalized);
      }
      return;
    }
    setProject(value);
  };

  const handleSave = () => {
    if (!goal) return;
    const trimmed = title.trim();
    if (!trimmed) return;
    const safeUnits = Number.isFinite(targetUnits) ? targetUnits : goal.targetUnits;
    onAddProject(project);
    onSubmit(goal.id, {
      title: trimmed,
      project,
      targetUnits: Math.max(1, safeUnits),
      unitLabel: unitLabel.trim() || goal.unitLabel,
      dueDate: dueDate ? toISODate(dueDate) : undefined,
    });
    onClose();
  };

  if (!goal) return null;

  return (
    <Dialog open={open} onOpenChange={(state) => { if (!state) onClose(); }}>
      <DialogContent className={cx("max-w-2xl", surface.dialog)} style={surface.dialogStyle}>
        <DialogHeader>
          <DialogTitle>{t.edit}</DialogTitle>
        </DialogHeader>
        <div className="space-y-3">
          <div className="space-y-1">
            <Label>{t.titleLbl}</Label>
            <Input value={title} onChange={(e)=>setTitle(e.target.value)} />
          </div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label>{t.project}</Label>
              <Select value={project} onValueChange={handleProjectChange}>
                <SelectTrigger><SelectValue /></SelectTrigger>
                <SelectContent>
                  {projectOptions.map(opt => (
                    <SelectItem key={opt} value={opt}>{opt}</SelectItem>
                  ))}
                  <SelectItem value={NEW_PROJECT_VALUE}>+ {t.newProject ?? "Nuevo proyecto"}</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label>{t.goalDate}</Label>
              <Input type="date" value={dueDate} onChange={(e)=>setDueDate(e.target.value)} />
            </div>
          </div>
          <div className="grid grid-cols-2 gap-2">
            <div className="space-y-1">
              <Label>{t.goalUnits}</Label>
              <Input
                type="number"
                value={targetUnits}
                onChange={(e)=>{
                  const value = parseInt(e.target.value || '0', 10);
                  setTargetUnits(Number.isNaN(value) ? 0 : value);
                }}
              />
            </div>
            <div className="space-y-1">
              <Label>{t.unitLabel}</Label>
              <Input value={unitLabel} onChange={(e)=>setUnitLabel(e.target.value)} />
            </div>
          </div>
          <div className="flex justify-end gap-2">
            <Button variant="ghost" onClick={onClose}>{t.cancel}</Button>
            <Button onClick={handleSave}>{t.saveChanges}</Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

function ReviewForm({ onSubmit, t }: { onSubmit: (notes?: string) => void; t:any }) {
  const [notes, setNotes] = useState("");
  return (
    <div className="space-y-3">
      <Label>{t.notes}</Label>
      <Textarea value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Breve, honesto y sin drama." />
      <Button onClick={() => onSubmit(notes.trim() || undefined)}>{t.save}</Button>
    </div>
  );
}

function GoalMiniChart({ goal, t }: { goal: Goal; t:any }) {
  const data = useMemo(() => {
    const map: Record<string, number> = {};
    goal.history.forEach(h => {
      const k = h.date.slice(0,10);
      map[k] = (map[k] || 0) + h.units;
    });
    const now = new Date(todayISO());
    const days = [...Array(21)].map((_,i) => {
      const d = new Date(now);
      d.setDate(now.getDate() - (20 - i));
      const key = d.toISOString().slice(0,10);
      return { date: format(d, 'dd/MM'), units: map[key] || 0 };
    });
    return days;
  }, [goal.history]);

  const totalDone = goal.history.reduce((a,b) => a + b.units, 0);
  const pct = Math.min(100, Math.round((totalDone / Math.max(1, goal.targetUnits)) * 100));

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div className="md:col-span-2 h-28">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={data}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="units" />
          </BarChart>
        </ResponsiveContainer>
      </div>
      <div className="flex flex-col items-center justify-center rounded-xl border p-3">
        <div className="text-xs text-neutral-500">{t.progress}</div>
        <div className="text-2xl font-bold">{pct}%</div>
        <div className="text-xs text-neutral-500">{totalDone}/{goal.targetUnits} {goal.unitLabel}</div>
      </div>
    </div>
  );
}

// ===== Semana =====
function WeekPlan({ tasks, addTask, t, defaultProject }: { tasks: Task[]; addTask: (t: Omit<Task, 'id'|'createdAt'|'done'>)=>void; t:any; defaultProject: string }){
  const days = ['Lun','Mar','Mié','Jue','Vie','Sáb','Dom'];
  const todayIdx = new Date().getDay(); // 0=Dom
  function addQuick(dayOffset:number){
    const title = prompt(`Tarea (${days[(todayIdx+6+dayOffset)%7]})`);
    if(title){
      const d = new Date(); d.setDate(d.getDate()+dayOffset);
      addTask({ title, project: defaultProject, estimateMin:30, points:20, dueDate: toISODate(d.toISOString()) });
    }
  }
  return (
    <div className="grid grid-cols-1 md:grid-cols-7 gap-3">
      {[...Array(7)].map((_,i)=>{
        const d = new Date(); d.setDate(d.getDate() - ((todayIdx+6)%7) + i);
        const key = d.toISOString().slice(0,10);
        const dayTasks = tasks.filter(t=> (t.dueDate||'').slice(0,10)===key);
        return (
          <SurfaceCard key={i}>
            <CardHeader className="pb-2"><CardTitle className="text-base">{days[i]} · {format(d,'dd/MM')}</CardTitle></CardHeader>
            <CardContent className="space-y-2">
              <Button variant="secondary" onClick={()=>addQuick(i-((todayIdx+6)%7))} className="w-full">{t.add}</Button>
              <div className="space-y-2">
                {dayTasks.map(x=> <div key={x.id} className="text-sm rounded-lg border p-2">{x.title}</div>)}
                {dayTasks.length===0 && <div className="text-xs text-neutral-500">—</div>}
              </div>
            </CardContent>
          </SurfaceCard>
        );
      })}
    </div>
  );
}

// ===== Backlog =====
function Backlog({ tasks, setTasks, t }: { tasks: Task[]; setTasks: React.Dispatch<React.SetStateAction<Task[]>>; t:any }){
  const undone = tasks.filter(x=>!x.done).sort((a,b)=> (a.priority==="high"?0:1)-(b.priority==="high"?0:1));
  function bump(id:string){ setTasks(prev=> prev.map(x=> x.id===id?{...x, priority: x.priority==='high'?'med':'high'}:x)); }
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
      <SurfaceCard>
        <CardHeader className="pb-2"><CardTitle>Criticas</CardTitle></CardHeader>
        <CardContent className="space-y-2">
          {undone.filter(x=>x.priority==='high').map(x=> <BLRow key={x.id} task={x} bump={bump} t={t} />)}
          {undone.filter(x=>x.priority==='high').length===0 && <div className="text-sm text-neutral-500">Vacío</div>}
        </CardContent>
      </SurfaceCard>
      <SurfaceCard>
        <CardHeader className="pb-2"><CardTitle>Normales</CardTitle></CardHeader>
        <CardContent className="space-y-2">
          {undone.filter(x=>x.priority!=='high').map(x=> <BLRow key={x.id} task={x} bump={bump} t={t} />)}
          {undone.filter(x=>x.priority!=='high').length===0 && <div className="text-sm text-neutral-500">Vacío</div>}
        </CardContent>
      </SurfaceCard>
    </div>
  );
}
function BLRow({ task, bump, t }:{ task:Task; bump:(id:string)=>void; t:any }){
  return <div className="rounded-xl border p-2 text-sm flex items-center justify-between">
    <div>
      <div className="font-medium">{task.title}</div>
      <div className="text-xs text-neutral-500">{task.project} · {task.estimateMin}min</div>
    </div>
    <Button variant="secondary" size="sm" onClick={()=>bump(task.id)}>
      {task.priority==='high' ? t.priorityDemote : t.priorityPromote}
    </Button>
  </div>;
}

// ===== Timer de enfoque =====
function FocusTimer({ cfg, setCfg, t }: { cfg: Cfg; setCfg: (c: Cfg)=>void; t:any }){
  const [mode, setMode] = useState<'focus'|'break'>('focus');
  const [sec, setSec] = useState(cfg.focusBlockMin*60);
  const intervalRef = useRef<number | null>(null);

  function tick(){ setSec(s=> Math.max(0, s-1)); }
  useEffect(()=>{ if(sec===0){
    if(cfg.sound) playBeep();
    if(cfg.notifications && 'Notification' in window && Notification.permission==='granted') new Notification(mode==='focus'?'Fin del bloque':'Fin del descanso');
    const next = mode==='focus'?'break':'focus';
    setMode(next); setSec((next==='focus'?cfg.focusBlockMin:cfg.breakMin)*60);
  }}, [sec]);

  function start(){ if(intervalRef.current) return; intervalRef.current = window.setInterval(tick, 1000); }
  function pause(){ if(intervalRef.current){ clearInterval(intervalRef.current); intervalRef.current=null; } }
  function reset(){ pause(); setMode('focus'); setSec(cfg.focusBlockMin*60); }

  const mm = String(Math.floor(sec/60)).padStart(2,'0');
  const ss = String(sec%60).padStart(2,'0');

  return (
    <SurfaceCard>
      <CardHeader className="pb-2 flex items-center justify-between">
        <CardTitle className="flex items-center gap-2"><Timer className="h-5 w-5" />{t.pomodoro}</CardTitle>
        <div className="text-xs text-neutral-500 flex items-center gap-2"><Bell className="h-4 w-4" />{t.allowNotif}: {cfg.notifications? 'On':'Off'}</div>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="text-center">
          <div className="text-5xl font-bold tracking-tight">{mm}:{ss}</div>
          <div className="text-xs text-neutral-500">{mode==='focus'? t.focusBlock : t.break}</div>
        </div>
        <div className="flex gap-2 justify-center">
          <Button onClick={start}>{t.start}</Button>
          <Button variant="secondary" onClick={pause}>{t.pause}</Button>
          <Button variant="ghost" onClick={reset}>{t.reset}</Button>
        </div>
        <div className="grid grid-cols-2 gap-3">
          <div className="space-y-1">
            <Label>{t.focusBlock} (min)</Label>
            <Input type="number" value={cfg.focusBlockMin} onChange={(e)=> setCfg({ ...cfg, focusBlockMin: Math.max(5, parseInt(e.target.value||'0')) })} />
          </div>
          <div className="space-y-1">
            <Label>{t.break} (min)</Label>
            <Input type="number" value={cfg.breakMin} onChange={(e)=> setCfg({ ...cfg, breakMin: Math.max(1, parseInt(e.target.value||'0')) })} />
          </div>
          <div className="flex items-center gap-2">
            <Switch checked={cfg.sound} onCheckedChange={(v)=> setCfg({ ...cfg, sound: !!v })} /> <Label>Sonido</Label>
          </div>
          <div className="flex items-center gap-2">
            <Switch checked={cfg.notifications} onCheckedChange={(v)=> setCfg({ ...cfg, notifications: !!v })} /> <Label>{t.allowNotif}</Label>
          </div>
        </div>
      </CardContent>
    </SurfaceCard>
  );
}

function SettingsPane({ cfg, setCfg, exportAll, importAll, t, projects, onRemoveProject, uiPrefs, setUiPrefs, defaultProjectName, supportProjectName }:{ cfg: Cfg; setCfg:(c:Cfg)=>void; exportAll:()=>void; importAll:(f:File)=>void; t:any; projects: string[]; onRemoveProject: (name: string) => void; uiPrefs: UiPreferences; setUiPrefs: (prefs: UiPreferences) => void; defaultProjectName: string; supportProjectName: string }){
  const fileRef = useRef<HTMLInputElement|null>(null);
  const surface = useSurface();
  const reserved = useMemo(() => {
    return new Set([defaultProjectName.toLowerCase(), supportProjectName.toLowerCase()]);
  }, [defaultProjectName, supportProjectName]);

  const updateUiPref = <K extends keyof UiPreferences>(key: K, value: UiPreferences[K]) => {
    setUiPrefs({ ...uiPrefs, [key]: value });
  };

  const accentOptions: { key: UiPreferences["accent"]; label: string; preview: string }[] = [
    { key: "emerald", label: t.accentEmerald, preview: "from-emerald-400 via-emerald-500 to-sky-400" },
    { key: "violet", label: t.accentViolet, preview: "from-fuchsia-400 via-violet-500 to-sky-500" },
    { key: "amber", label: t.accentAmber, preview: "from-amber-400 via-orange-500 to-rose-400" },
    { key: "sky", label: t.accentSky, preview: "from-sky-400 via-cyan-500 to-indigo-400" },
    { key: "slate", label: t.accentSlate, preview: "from-slate-400 via-slate-500 to-zinc-500" },
  ];

  const styleOptions: { key: UiPreferences["cardStyle"]; label: string }[] = [
    { key: "glass", label: t.cardStyleGlass },
    { key: "solid", label: t.cardStyleSolid },
    { key: "gradient", label: t.cardStyleGradient },
  ];

  const radiusOptions: { key: UiPreferences["cardRadius"]; label: string }[] = [
    { key: "md", label: t.radiusMd },
    { key: "lg", label: t.radiusLg },
    { key: "xl", label: t.radiusXl },
  ];

  const densityOptions: { key: UiPreferences["density"]; label: string }[] = [
    { key: "comfortable", label: t.densityComfortable },
    { key: "cozy", label: t.densityCozy },
    { key: "compact", label: t.densityCompact },
  ];

  const shadowOptions: { key: UiPreferences["cardShadow"]; label: string }[] = [
    { key: "soft", label: t.shadowSoft },
    { key: "medium", label: t.shadowMedium },
    { key: "bold", label: t.shadowBold },
  ];

  const fieldOptions: { key: UiPreferences["fieldStyle"]; label: string }[] = [
    { key: "glassy", label: t.fieldGlassy },
    { key: "solid", label: t.fieldSolid },
    { key: "minimal", label: t.fieldMinimal },
  ];

  const dialogToneOptions: { key: UiPreferences["dialogTone"]; label: string }[] = [
    { key: "neutral", label: t.dialogToneNeutral },
    { key: "accent", label: t.dialogToneAccent },
    { key: "inverted", label: t.dialogToneInverted },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <SurfaceCard>
        <CardHeader className="pb-2"><CardTitle>Preferencias</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2"><Sun className="h-4 w-4" />{t.light} / <Moon className="h-4 w-4" />{t.dark}</div>
            <Switch checked={cfg.theme==='dark'} onCheckedChange={(v)=> setCfg({ ...cfg, theme: v? 'dark':'light' })} />
          </div>
          <div className="space-y-1">
            <Label>{t.language}</Label>
            <Select value={cfg.lang} onValueChange={(v)=> setCfg({ ...cfg, lang: v as any })}>
              <SelectTrigger className={cx(surface.field, "h-11")}><SelectValue /></SelectTrigger>
              <SelectContent>
                <SelectItem value="es">Español</SelectItem>
                <SelectItem value="en">English</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            <div className="space-y-1">
              <Label>{t.aiCapacityLabel}</Label>
              <Input
                type="number"
                value={cfg.dailyCapacityMin}
                min={30}
                className={cx(surface.field, "h-11")}
                onChange={(e)=> setCfg({ ...cfg, dailyCapacityMin: Math.max(30, parseInt(e.target.value || '0', 10)) })}
              />
            </div>
            <div className="space-y-1">
              <Label>{t.aiMinSlotsLabel}</Label>
              <Input
                type="number"
                value={cfg.dailyMinSlots}
                min={1}
                className={cx(surface.field, "h-11")}
                onChange={(e)=> setCfg({ ...cfg, dailyMinSlots: Math.max(1, parseInt(e.target.value || '0', 10)) })}
              />
            </div>
          </div>
        </CardContent>
      </SurfaceCard>

      <SurfaceCard>
        <CardHeader className="pb-2"><CardTitle>{t.interfaceStyle}</CardTitle></CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.cardStyleLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {styleOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.cardStyle === option.key ? "default" : "secondary"}
                  className="rounded-full"
                  onClick={() => updateUiPref("cardStyle", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.cardRadiusLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {radiusOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.cardRadius === option.key ? "default" : "ghost"}
                  className="rounded-full border"
                  onClick={() => updateUiPref("cardRadius", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.cardShadowLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {shadowOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.cardShadow === option.key ? "default" : "ghost"}
                  className="rounded-full"
                  onClick={() => updateUiPref("cardShadow", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.accentPalette}</Label>
            <div className="grid grid-cols-2 gap-2">
              {accentOptions.map(option => (
                <button
                  key={option.key}
                  onClick={() => updateUiPref("accent", option.key)}
                  className={cx(
                    "group relative overflow-hidden rounded-2xl border p-3 text-left transition-all",
                    uiPrefs.accent === option.key ? surface.accentRing : "border-neutral-200/60 dark:border-neutral-700/60",
                  )}
                >
                  <span className="text-sm font-semibold">{option.label}</span>
                  <span className={cx("mt-2 block h-2 w-full rounded-full bg-gradient-to-r", option.preview)} />
                </button>
              ))}
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.fieldStyleLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {fieldOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.fieldStyle === option.key ? "default" : "ghost"}
                  className="rounded-full"
                  onClick={() => updateUiPref("fieldStyle", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.densityLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {densityOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.density === option.key ? "default" : "ghost"}
                  className="rounded-full"
                  onClick={() => updateUiPref("density", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            <div className="space-y-1">
              <Label>{t.defaultProjectLabel}</Label>
              <Input
                value={uiPrefs.defaultProjectName}
                onChange={(e) => updateUiPref("defaultProjectName", e.target.value)}
                placeholder={defaultProjectName}
                className={cx(surface.field, "h-11")}
              />
            </div>
            <div className="space-y-1">
              <Label>{t.supportProjectLabel}</Label>
              <Input
                value={uiPrefs.supportProjectName}
                onChange={(e) => updateUiPref("supportProjectName", e.target.value)}
                placeholder={supportProjectName}
                className={cx(surface.field, "h-11")}
              />
            </div>
          </div>
          <div className="space-y-2">
            <Label className="text-xs uppercase tracking-wide text-neutral-500 dark:text-neutral-400">{t.dialogToneLabel}</Label>
            <div className="flex flex-wrap gap-2">
              {dialogToneOptions.map(option => (
                <Button
                  key={option.key}
                  variant={uiPrefs.dialogTone === option.key ? "default" : "ghost"}
                  className="rounded-full"
                  onClick={() => updateUiPref("dialogTone", option.key)}
                >
                  {option.label}
                </Button>
              ))}
            </div>
          </div>
          <div className="space-y-1">
            <Label>
              {t.dialogBlur}: <span className="font-semibold">{uiPrefs.dialogBlur}px</span>
            </Label>
            <Input
              type="range"
              min={0}
              max={24}
              value={uiPrefs.dialogBlur}
              onChange={(e)=> updateUiPref("dialogBlur", parseInt(e.target.value || '0', 10))}
              className="w-full"
            />
          </div>
        </CardContent>
      </SurfaceCard>

      <SurfaceCard>
        <CardHeader className="pb-2"><CardTitle>Datos</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <div className="flex gap-2">
            <Button onClick={exportAll} className="flex items-center gap-2"><Download className="h-4 w-4" /> {t.export}</Button>
            <input type="file" ref={fileRef} className="hidden" accept="application/json" onChange={(e)=>{ const f=e.target.files?.[0]; if(f) importAll(f); }} />
            <Button variant="secondary" onClick={()=> fileRef.current?.click()} className="flex items-center gap-2"><Upload className="h-4 w-4" /> {t.import}</Button>
          </div>
          <div className="text-xs text-neutral-500 flex items-center gap-2"><Keyboard className="h-4 w-4" />Atajos: Alt+N tarea rápida, Alt+D calificar día.</div>
        </CardContent>
      </SurfaceCard>

      <SurfaceCard className="md:col-span-2">
        <CardHeader className="pb-2"><CardTitle>{t.manageProjects}</CardTitle></CardHeader>
        <CardContent className="space-y-3">
          <div className="text-xs text-neutral-500 dark:text-neutral-400">{t.manageProjectsHint}</div>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2">
            {projects.filter(project => !reserved.has(project.toLowerCase())).map(project => (
              <div key={project} className="flex items-center justify-between rounded-xl border px-3 py-2 text-sm">
                <span>{project}</span>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => onRemoveProject(project)}
                  aria-label={`${t.removeProject} ${project}`}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            ))}
            {projects.filter(project => !reserved.has(project.toLowerCase())).length === 0 && (
              <div className="rounded-xl border border-dashed px-3 py-4 text-sm text-neutral-500 dark:text-neutral-400">
                {t.noCustomProjects}
              </div>
            )}
          </div>
        </CardContent>
      </SurfaceCard>
    </div>
  );
}

function ThemeToggle({ cfg, setCfg, t }:{ cfg: Cfg; setCfg:(c:Cfg)=>void; t:any }){
  return (
    <div className="flex items-center gap-2">
      <Select value={cfg.lang} onValueChange={(v)=> setCfg({ ...cfg, lang: v as any })}>
        <SelectTrigger className="h-8 w-[110px]"><SelectValue /></SelectTrigger>
        <SelectContent>
          <SelectItem value="es">Español</SelectItem>
          <SelectItem value="en">English</SelectItem>
        </SelectContent>
      </Select>
      <Button variant="secondary" size="icon" onClick={()=> setCfg({ ...cfg, theme: cfg.theme==='dark'?'light':'dark' })}>{cfg.theme==='dark'? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />}</Button>
    </div>
  );
}

function Templates({
  addTask,
  addGoal,
  projects,
  onAddProject,
  t,
  defaultProject,
  lang,
  supportProject,
}: {
  addTask: (t: Omit<Task, "id" | "createdAt" | "done">) => void;
  addGoal: (g: Omit<Goal, "id" | "createdAt" | "history">) => void;
  projects: string[];
  onAddProject: (name: string) => void;
  t: any;
  defaultProject: string;
  lang: "es" | "en";
  supportProject: string;
}) {
  const isSpanish = lang === "es";
  const [targetProject, setTargetProject] = useState(defaultProject);
  const [intensity, setIntensity] = useState<"light" | "balanced" | "turbo">("balanced");
  const [dueDate, setDueDate] = useState<string>("");
  const [status, setStatus] = useState<string | null>(null);

  useEffect(() => {
    setTargetProject(prev => {
      if (projects.includes(prev)) return prev;
      return projects[0] ?? defaultProject;
    });
  }, [projects, defaultProject]);

  useEffect(() => {
    if (!projects.includes(targetProject)) {
      setTargetProject(projects[0] ?? defaultProject);
    }
  }, [targetProject, projects]);

  useEffect(() => {
    setTargetProject(defaultProject);
  }, [defaultProject]);

  const handleProjectChange = (value: string) => {
    if (value === NEW_PROJECT_VALUE) {
      const name = prompt(t.newProjectPrompt ?? t.newProject ?? "Nuevo proyecto");
      const normalized = name?.trim();
      if (normalized) {
        onAddProject(normalized);
        setTargetProject(normalized);
      }
      return;
    }
    setTargetProject(value);
  };

  const intensityLabel = intensity === "light" ? t.templateLight : intensity === "turbo" ? t.templateTurbo : t.templateBalanced;
  const multiplier = intensity === "light" ? 0.75 : intensity === "turbo" ? 1.35 : 1;
  const resolvedDue = dueDate ? toISODate(dueDate) : undefined;

  const packs = useMemo(() => {
    return [
      {
        id: "daily33",
        title: isSpanish ? "Pack: Día base 3×3" : "Pack: Daily 3×3",
        description: isSpanish
          ? "Tres apuestas: foco, avance real y mantenimiento con intención."
          : "Three bets: focus, meaningful progress, and system maintenance.",
        tasks: [
          { title: isSpanish ? "Tarea crítica del día" : "Critical task of the day", project: "__target__", estimateMin: 60, points: 40, priority: "high" as const },
          { title: isSpanish ? "Avance en meta principal (+1 unidad)" : "Push main goal (+1 unit)", project: "__target__", estimateMin: 40, points: 25, priority: "med" as const },
          { title: isSpanish ? "Mantenimiento del sistema (archivos/orden)" : "System maintenance (files/order)", project: "__support__", estimateMin: 20, points: 12, priority: "low" as const },
        ],
      },
      {
        id: "exam",
        title: isSpanish ? "Pack: Examen turbo" : "Pack: Exam turbo",
        description: isSpanish
          ? "Simula examen, repasa temario y cierra pendientes logísticos."
          : "Simulate the exam, review syllabus, and close logistics.",
        tasks: [
          { title: isSpanish ? "Repaso temario completo" : "Full syllabus review", project: "__target__", estimateMin: 90, points: 45, priority: "high" as const },
          { title: isSpanish ? "Resolver 3 exámenes pasados" : "Solve 3 past exams", project: "__target__", estimateMin: 120, points: 60, priority: "high" as const },
          { title: isSpanish ? "Checklist materiales y descanso" : "Material checklist & rest", project: "__support__", estimateMin: 20, points: 15, priority: "med" as const },
        ],
      },
      {
        id: "research",
        title: isSpanish ? "Pack: Investigación" : "Pack: Research sprint",
        description: isSpanish
          ? "Lectura con notas y páginas nuevas para tu manuscrito."
          : "Read with notes and ship new manuscript pages.",
        goals: [
          { title: isSpanish ? "Borrador sección Métodos" : "Draft methods section", project: "__target__", targetUnits: 4, unitLabel: isSpanish ? "páginas" : "pages" },
        ],
        tasks: [
          { title: isSpanish ? "Leer 2 papers clave y anotar hallazgos" : "Read 2 key papers and capture insights", project: "__target__", estimateMin: 70, points: 30, priority: "med" as const },
          { title: isSpanish ? "Escribir 2 páginas nuevas" : "Write 2 fresh pages", project: "__target__", estimateMin: 60, points: 35, priority: "high" as const },
        ],
      },
      {
        id: "courses",
        title: isSpanish ? "Pack: Cursos sin backlog" : "Pack: Course momentum",
        description: isSpanish
          ? "Asegura avance en el módulo actual y aplica lo aprendido."
          : "Advance the current module and apply the lesson.",
        goals: [
          { title: isSpanish ? "Terminar módulo actual" : "Finish current module", project: "__target__", targetUnits: 3, unitLabel: isSpanish ? "lecciones" : "lessons" },
        ],
        tasks: [
          { title: isSpanish ? "Ver 1 lección y tomar notas" : "Watch 1 lesson and take notes", project: "__target__", estimateMin: 45, points: 20, priority: "med" as const },
          { title: isSpanish ? "Resolver ejercicios del módulo" : "Complete module exercises", project: "__target__", estimateMin: 45, points: 25, priority: "med" as const },
          { title: isSpanish ? "Aplicar el concepto en mini proyecto" : "Apply concept in a mini project", project: "__target__", estimateMin: 60, points: 30, priority: "high" as const },
        ],
      },
    ];
  }, [isSpanish]);

  const resolveProject = (value: string) => {
    if (value === "__target__") return targetProject;
    if (value === "__support__") return supportProject || targetProject;
    return value;
  };

  const applyPack = (pack: typeof packs[number]) => {
    onAddProject(targetProject);
    pack.goals?.forEach(goal => {
      addGoal({
        title: goal.title,
        project: resolveProject(goal.project),
        targetUnits: goal.targetUnits,
        unitLabel: goal.unitLabel,
        dueDate: resolvedDue ?? goal.dueDate,
      });
    });
    pack.tasks?.forEach(task => {
      const estimate = Math.max(10, Math.round((task.estimateMin * multiplier) / 5) * 5);
      const points = Math.max(10, Math.round((task.points ?? estimate / 2) / 5) * 5);
      addTask({
        title: task.title,
        project: resolveProject(task.project),
        estimateMin: estimate,
        points,
        priority: task.priority ?? "med",
        dueDate: resolvedDue,
        notes: task.notes,
      });
    });
    setStatus(`${pack.title} · ${t.templateSuccess}`);
    setTimeout(() => setStatus(null), 3500);
  };

  return (
    <div className="space-y-4">
      <div className="flex flex-col gap-3 xl:flex-row xl:items-end xl:justify-between">
        <div className="grid grid-cols-1 gap-3 md:grid-cols-3 xl:flex-1">
          <div className="space-y-1">
            <Label>{t.templateProjectLabel}</Label>
            <Select value={targetProject} onValueChange={handleProjectChange}>
              <SelectTrigger><SelectValue /></SelectTrigger>
              <SelectContent>
                {projects.map(project => (
                  <SelectItem key={project} value={project}>{project}</SelectItem>
                ))}
                <SelectItem value={NEW_PROJECT_VALUE}>+ {t.newProject ?? "Nuevo proyecto"}</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-1">
            <Label>{t.templateIntensity}</Label>
            <Select value={intensity} onValueChange={(value)=> setIntensity(value as typeof intensity)}>
              <SelectTrigger><SelectValue placeholder={intensityLabel} /></SelectTrigger>
              <SelectContent>
                <SelectItem value="light">{t.templateLight}</SelectItem>
                <SelectItem value="balanced">{t.templateBalanced}</SelectItem>
                <SelectItem value="turbo">{t.templateTurbo}</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-1">
            <Label>{t.due}</Label>
            <Input type="date" value={dueDate} onChange={(e)=>setDueDate(e.target.value)} />
          </div>
        </div>
        {status && (
          <div className="flex items-center gap-2 rounded-xl border border-emerald-500/40 bg-emerald-500/10 px-3 py-2 text-sm text-emerald-600 dark:text-emerald-300">
            <PartyPopper className="h-4 w-4" /> {status}
          </div>
        )}
      </div>

      <div className="grid grid-cols-1 gap-3 md:grid-cols-2 xl:grid-cols-4">
        {packs.map(pack => (
          <SurfaceCard key={pack.id} className="relative overflow-hidden border border-neutral-200/70 shadow-sm transition-all hover:shadow-xl dark:border-neutral-700">
            <CardHeader className="pb-2">
              <CardTitle>{pack.title}</CardTitle>
              <p className="text-sm text-neutral-500 dark:text-neutral-400">{pack.description}</p>
            </CardHeader>
            <CardContent className="space-y-3">
              <ul className="space-y-1 text-xs text-neutral-600 dark:text-neutral-300">
                {pack.tasks?.map((task, idx) => (
                  <li key={`task-${pack.id}-${idx}`}>{resolveProject(task.project)} · {task.title}</li>
                ))}
                {pack.goals?.map((goal, idx) => (
                  <li key={`goal-${pack.id}-${idx}`} className="font-semibold text-emerald-600 dark:text-emerald-300">
                    {resolveProject(goal.project)} · {goal.title}
                  </li>
                ))}
              </ul>
              <div className="text-xs text-neutral-500 dark:text-neutral-400">
                {intensityLabel} · {resolvedDue ? (isSpanish ? `Fecha ${format(new Date(resolvedDue), 'dd/MM')}` : `Due ${format(new Date(resolvedDue), 'MM/dd')}`) : isSpanish ? "Sin fecha fija" : "No due date"}
              </div>
              <Button className="w-full" onClick={() => applyPack(pack)}>
                {isSpanish ? "Aplicar" : "Apply"}
              </Button>
            </CardContent>
          </SurfaceCard>
        ))}
      </div>
    </div>
  );
}
